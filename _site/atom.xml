<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>疯子伟哥的世界</title>
   <link href="http://www.itweige.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://www.itweige.com" rel="alternate" type="text/html" />
   <updated>2014-06-12T17:05:46+08:00</updated>
   <id>http://www.itweige.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>初探WebSocket</title>
     <link href="http://itweige.com/tomcat-websocket"/>
     <updated>2014-06-13T00:00:00+08:00</updated>
     <id>http://itweige.com/tomcat-websocket</id>
     <content type="html">&lt;h2&gt;背景&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;　　对于HTTP/HTTPS协议的应用，由于它们是非连接协议，所以通常只能由客户端主动向服务端发送请求才能获得服务端的响应并取得相关的数据。&lt;br/&gt;
　　而当前越来越多的应用希望能够及时获取服务端提供的数据，甚至希望能够达到接近实时的数据交换(例如很多网站提供的在线客户系统)。&lt;br/&gt;
　　为达到此Push目的，通常采用的技术主要有轮询、长轮询、流等，而伴随着HTML5的出现，相对更优异的&lt;strong&gt;WebSocket方案&lt;/strong&gt;也应运而生。&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr/&gt;


&lt;h2&gt;Push技术&lt;/h2&gt;

&lt;h3&gt;轮询&lt;/h3&gt;

&lt;p&gt;　　轮询是由客户端定时向服务端发起查询数据的请求的一种实现方式。早期的轮询是通过不断自动刷新页面而实现的(在那个基本是IE统治浏览器的时代，那不断刷新页面产生的噪声就难以让人忍受)，后来随着技术的发展，特别是Ajax技术的出现，实现了无刷新更新数据。&lt;strong&gt;但本质上这些方式均是客户端定时轮询服务端，这种方式的最显著的缺点是如果客户端数量庞大并且定时轮询间隔较短服务端将承受响应这些客户端海量请求的巨大的压力。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;长轮询&lt;/h3&gt;

&lt;p&gt;　　在数据更新不够频繁的情况下，使用轮询方法获取数据时客户端经常会得到没有数据的响应，显然这样的轮询是一个浪费网络资源的无效的轮询。长轮询则是针对普通轮询的这种缺陷的一种改进方案，其具体实现方式是如果当前请求没有数据可以返回，则继续保持当前请求的网络连接状态，直到服务端有数据可以返回或者连接超时。长轮询通过这种方式减少了客户端与服务端交互的次数，避免了一些无谓的网络连接。&lt;strong&gt;但是如果数据变更较为频繁，则长轮询方式与普通轮询在性能上并无显著差异。同时，增加连接的等待时间，往往意味着并发性能的下降,服务器hold连接会消耗资源。&lt;/strong&gt;实现实例有：WebQQ、Hi网页版、Facebook IM等。&lt;/p&gt;

&lt;h3&gt;流--长连接&lt;/h3&gt;

&lt;p&gt;　　所谓流（也称长连接方式）是指客户端在页面之下向服务端发起一个长连接请求，服务端收到这个请求后响应它并不断更新连接状态，以确保这个连接在客户端与服务端之间一直有效。&lt;strong&gt;服务端可以通过这个连接将数据主动推送到客户端。显然，这种方案实现起来相对比较麻烦，而且可能被防火墙阻断。&lt;/strong&gt;当前流行的comet等方案都是基于此提出的。&lt;br/&gt;
　　参考链接：&lt;a href=&quot;http://www.dewen.org/q/665/&quot; title=&quot;http://www.dewen.org/q/665/&quot;&gt;http://www.dewen.org/q/665/&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;h2&gt;WebSocket协议&lt;/h2&gt;

&lt;p&gt;　　WebSocket是为解决客户端与服务端实时通信而产生的技术。&lt;strong&gt;其本质是先通过HTTP-/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，此后服务端与客户端通过此TCP连接进行实时通信。&lt;/strong&gt;&lt;br/&gt;
　　&lt;strong&gt;Tomcat 7.0.27开始支持WebSocket服务&lt;/strong&gt;，在tomcat webapps/examples目录下有关于websocket的示例及源码，有兴趣的可以自行查看。&lt;br/&gt;
　　WebSocket规范当前还没有正式版本，草案变化也较为迅速。Tomcat7当前支持 RFC6455 定义的WebSocket，而RFC 6455目前还未成型，将来可能会修复一些Bug，甚至协议本身也可能会产生一些变化。&lt;strong&gt;RFC6455定义的WebSocket协议由握手和数据传输两个部分组成：&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;握手信息格式&lt;/h3&gt;

&lt;p&gt;　　首先是通过握手信息建立TCP链接，为后续的信息传输做好准备。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;来自客户端的&lt;strong&gt;握手信息&lt;/strong&gt;类似如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
&lt;/code&gt;&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;服务端的&lt;strong&gt;握手信息&lt;/strong&gt;类似如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;传输信息格式&lt;/h3&gt;

&lt;p&gt;　　一旦客户端和服务端都发送了握手信息并且成功握手，则数据传输部分将开始。数据传输对客户端和服务端而言都是一个双工通信通道，客户端和服务端来回传递的数据称之为“消息”。&lt;br/&gt;
　　客户端通过WebSocket URI发起WebSocket连接，WebSocket URIs模式定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]
wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;　　ws是普通的WebSocket通信协议，而wss是安全的WebSocket通信协议(就像HTTP与HTTPS之间的差异一样)。在缺省情况下，ws的端口是80而wss的端口是443(与HTTP/HTTPS是相同的嘛！)。当然也可以修改它的端口号，若改为8000，则形式如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ws://localhost:8000/examples/websocket/chat  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;strong&gt;建立连接后，随后通过socket.send(message);即可实现消息的发送和接收。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;优势所在&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;a) 服务器与客户端之间交换的标头信息很小，大概只有2字节； &lt;br/&gt;
b) 客户端与服务器都可以主动传送数据给对方，真正的全双工；&lt;br/&gt;
c) 不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源；&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr/&gt;


&lt;h2&gt;WebSocket实例&lt;/h2&gt;

&lt;p&gt;　　Tomcat7提供的与WebSocket相关的类均位于包org.apache.catalina.websocket之中，Servlet处理类以org.apache.catalina.websocket.WebSocketServlet作为它的父类。&lt;br/&gt;
　　WebSocketServlet：提供遵循RFC6455的WebSocket连接的Servlet基本实现。客户端使用WebSocket连接服务端时，需要将WebSocketServlet的子类作为连接入口。同时，该子类应当实现WebSocketServlet的抽象方法createWebSocketInbound，以便创建一个inbound实例(MessageInbound或StreamInbound)。&lt;br/&gt;
　　一个标准的websocket servlet如下所示，&lt;strong&gt;其核心逻辑是在收到客户端发来的消息后立即将其发回客户端&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package websocket.chat;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.atomic.AtomicInteger;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServletRequest;

import org.apache.catalina.websocket.MessageInbound;
import org.apache.catalina.websocket.StreamInbound;
import org.apache.catalina.websocket.WebSocketServlet;
import org.apache.catalina.websocket.WsOutbound;

@WebServlet(&quot;/ChatWebSocketServlet&quot;)
public class ChatWebSocketServlet extends WebSocketServlet {
    private static final long serialVersionUID = 1L;
    private static final String GUEST_PREFIX = &quot;Guest&quot;;
    //用于自动生成连接ID
    private final AtomicInteger connectionIds = new AtomicInteger(0);
    //用于保存所有连接Inbound的集合
    private final Set&amp;lt;ChatMessageInbound&amp;gt; connections =
            new CopyOnWriteArraySet&amp;lt;ChatMessageInbound&amp;gt;();
    //生成新的连接Inbound，WebSocketServlet必须实现该方法
    @Override
    protected StreamInbound createWebSocketInbound(String subProtocol,
            HttpServletRequest request) {
        return new ChatMessageInbound(connectionIds.incrementAndGet());
    }
    //聊天消息处理类
    private final class ChatMessageInbound extends MessageInbound {
        private final String nickname;
        private ChatMessageInbound(int id) {
            this.nickname = GUEST_PREFIX + id;
        }
        //创建新的连接时触发
        @Override
        protected void onOpen(WsOutbound outbound) {
            connections.add(this);
            String message = String.format(&quot;* %s %s&quot;,
                    nickname, &quot;has joined.&quot;);
            broadcast(message);
        }
        //关闭连接时触发
        @Override
        protected void onClose(int status) {
            connections.remove(this);
            String message = String.format(&quot;* %s %s&quot;,
                    nickname, &quot;has disconnected.&quot;);
            broadcast(message);
        }
        //发送二进制消息时触发
        @Override
        protected void onBinaryMessage(ByteBuffer message) throws IOException {
            throw new UnsupportedOperationException(
                    &quot;Binary message not supported.&quot;);
        }
        //发送文本消息时触发
        @Override
        protected void onTextMessage(CharBuffer message) throws IOException {
            // Never trust the client
            String filteredMessage = String.format(&quot;%s: %s&quot;,
                    nickname, message.toString());
            broadcast(filteredMessage);
        }
        //该方法向所有活动连接发送文本信息
        private void broadcast(String message) {
            for (ChatMessageInbound connection : connections) {
                try {
                    CharBuffer buffer = CharBuffer.wrap(message);
                    connection.getWsOutbound().writeTextMessage(buffer);
                } catch (IOException ignore) {
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　客户端在html页面中加入js处理代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        input#chat {
            width: 410px
        }
        #console-container {
            width: 400px;
        }
        #console {
            border: 1px solid #CCCCCC;
            border-right-color: #999999;
            border-bottom-color: #999999;
            height: 170px;
            overflow-y: scroll;
            padding: 5px;
            width: 100%;
        }
        #console p {
            padding: 0;
            margin: 0;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        var Chat = {};
        Chat.socket = null;
        Chat.connect = (function(host) {
            if (&#39;WebSocket&#39; in window) {
                Chat.socket = new WebSocket(host);
            } else if (&#39;MozWebSocket&#39; in window) {
                Chat.socket = new MozWebSocket(host);
            } else {
                Console.log(&#39;Error: WebSocket is not supported by this browser.&#39;);
                return;
            }
            //建立连接触发事件
            Chat.socket.onopen = function () {
                Console.log(&#39;Info: WebSocket connection opened.&#39;);
                document.getElementById(&#39;chat&#39;).onkeydown = function(event) {
                    if (event.keyCode == 13) {
                        Chat.sendMessage();
                    }
                };
            };
            //关闭连接触发事件
            Chat.socket.onclose = function () {
                document.getElementById(&#39;chat&#39;).onkeydown = null;
                Console.log(&#39;Info: WebSocket closed.&#39;);
            };
            //接收消息触发事件
            Chat.socket.onmessage = function (message) {
                Console.log(message.data);
            };
        });
        //初始化聊天对象方法，注意URL中的项目名称和Servlet名称
        Chat.initialize = function() {
            if (window.location.protocol == &#39;http:&#39;) {
                Chat.connect(&#39;ws://&#39; + window.location.host + &#39;/webchat/ChatWebSocketServlet&#39;);
            } else {
                Chat.connect(&#39;wss://&#39; + window.location.host + &#39;/webchat/ChatWebSocketServlet&#39;);
            }
        };
        //发送聊天信息方法
        Chat.sendMessage = (function() {
            var message = document.getElementById(&#39;chat&#39;).value;
            if (message != &#39;&#39;) {
                Chat.socket.send(message);
                document.getElementById(&#39;chat&#39;).value = &#39;&#39;;
            }
        });
        var Console = {};
        //显示消息记录
        Console.log = (function(message) {
            var console = document.getElementById(&#39;console&#39;);
            var p = document.createElement(&#39;p&#39;);
            p.style.wordWrap = &#39;break-word&#39;;
            p.innerHTML = message;
            console.appendChild(p);
            while (console.childNodes.length &amp;gt; 25) {
                console.removeChild(console.firstChild);
            }
            console.scrollTop = console.scrollHeight;
        });
        Chat.initialize();
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;input type=&quot;text&quot; placeholder=&quot;type and press enter to chat&quot; id=&quot;chat&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;div id=&quot;console-container&quot;&amp;gt;
        &amp;lt;div id=&quot;console&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码实现相关参考链接：&lt;a href=&quot;http://c5ms.iteye.com/blog/1527256&quot; title=&quot;http://c5ms.iteye.com/blog/1527256&quot;&gt;http://c5ms.iteye.com/blog/1527256&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>逐个击破之--Java NIO</title>
     <link href="http://itweige.com/Java-Nio"/>
     <updated>2014-06-09T00:00:00+08:00</updated>
     <id>http://itweige.com/Java-Nio</id>
     <content type="html">&lt;h2&gt;背景&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;Java 标准 IO 类库是 io 面向对象的一种抽象。基于本地方法的底层实现，我们无须关注底层实现。
InputStream\OutputStream( 字节流 ) ：一次传送一个字节。 Reader\Writer( 字符流 )
：一次一个字符。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;1.NIO介绍&lt;/h2&gt;

&lt;p&gt;　　Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。&lt;br/&gt;
　　NIO包（java.nio.*）引入了四个关键的抽象数据类型，它们共同解决传统的I/O类中的一些问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Buffer&lt;/strong&gt;：它是包含数据且用于读写的线形表结构，其中还提供了一个特殊类用于内存映射文件的I/O操作。数据的读写只能从buffer开始，并止于buffer。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Charset&lt;/strong&gt;：它提供Unicode字符串影射到字节序列以及逆影射的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channels&lt;/strong&gt;：包含socket，file和pipe三种管道，它实际上是双向交流的通道。 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Selector&lt;/strong&gt;：它将多元异步I/O操作集中到一个或多个线程中。Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.1 剖析Buffer&lt;/h3&gt;

&lt;p&gt;　　以下是Java NIO里关键的Buffer实现,这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　Java NIO中的Buffer用于和NIO通道channel进行交互，数据是从通道读入缓冲区，从缓冲区写入到通道中的。这是NIO与IO的一个重要区别：在面向流的I/O中您将数据直接写入或者将数据直接读到stream中，而在NIO中数据只能先读到或写入buffer中才能进行后续操作，buffer类似于一个中转站。&lt;strong&gt;简单的说Buffer是：一块连续的内存块，是NIO数据读或写的中转地。&lt;/strong&gt;&lt;br/&gt;
　　缓冲Buffer区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。使用Buffer读写数据一般遵循以下四个步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写入数据到Buffer&lt;/li&gt;
&lt;li&gt;调用flip()方法&lt;/li&gt;
&lt;li&gt;从Buffer中读取数据&lt;/li&gt;
&lt;li&gt;调用clear()方法或者compact()方法&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　一个 buffer 主要由 position、limit、capacity 三个变量来控制读写的过程。这三个变量在读和写时分别代表的含义如下：&lt;br/&gt;
　　&lt;img src=&quot;/images/projectImage/NIO-buffer-grid.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。示例程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {

  buf.flip();  //make buffer ready for read

  while(buf.hasRemaining()){
      System.out.print((char) buf.get()); // read 1 byte at a time
  }

  buf.clear(); //make buffer ready for writing
  bytesRead = inChannel.read(buf);
}
aFile.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.2 剖析Channel&lt;/h3&gt;

&lt;p&gt;　　Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。
正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。&lt;br/&gt;
　　简单的说Channel是：数据的源头或者数据的目的地，用于向buffer提供数据或者读取buffer数据，并且对I/O提供异步支持。&lt;br/&gt;
　　这些是Java NIO中最重要的通道的实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　在Channel接口中共定义了两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean isOpen();   //Tells whether or not this channel is open  
public void close() throws IOException();     //Close this channel  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　FileChannel : 使用以下三个方法可以得到一个FileChannel的实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FileInputStream.getChannel()  
FileOutputStream.getChannel()  
RandomAccessFile.getChannel()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面提到Channel是数据的源头或者数据的目的地，用于向bufer提供数据或者从buffer读取数据。那么在实现了该接口的子类中应该有相应的read和write方法。在FileChannel中有以下方法可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public long read(ByteBuffer[] dsts)//Reads a sequence of bytes from this channel into the given buffers.  
public long write(ByteBuffer[] srcs)//Writes a sequence of bytes to this channel from the given buffers.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　例子代码,下面是一个使用FileChannel读取数据到Buffer中的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

System.out.println(&quot;Read &quot; + bytesRead);
buf.flip();

while(buf.hasRemaining()){
System.out.print((char) buf.get());
}

buf.clear();
bytesRead = inChannel.read(buf);
}
aFile.close(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3 剖析Selector&lt;/h3&gt;

&lt;p&gt;　　原始的IO方式处理请求的操作是1v1，每一个请求服务器都会分配一个线程进行操作处理响应，在数据流量很低的情况下，长时间处于等待状态，严重浪费了系统性能。&lt;br/&gt;
　　Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。这是在一个单线程中使用一个Selector处理3个Channel的图示：&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/NIO-selector.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。&lt;/p&gt;

&lt;p&gt;　　通过调用Selector.open()方法创建一个Selector，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Selector selector = Selector.open();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;channel.configureBlocking(false);
SelectionKey key = channel.register(selector,Selectionkey.OP_READ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connect&lt;/li&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Read&lt;/li&gt;
&lt;li&gt;Write&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。&lt;br/&gt;
　　当向Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象，这个对象代表了注册到该Selector的通道，可以通过SelectionKey的selectedKeySet()方法访问这些对象，然后遍历这个已选择的键集合来访问就绪的通道。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set selectedKeys = selector.selectedKeys();
Iterator keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.
    } else if (key.isConnectable()) {
        // a connection was established with a remote server.
    } else if (key.isReadable()) {
        // a channel is ready for reading
    } else if (key.isWritable()) {
        // a channel is ready for writing
    }
    keyIterator.remove();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2 Java NIO与IO的比较&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;面向流与面向缓冲&lt;/strong&gt;&lt;br/&gt;
　　Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;阻塞与非阻塞IO&lt;/strong&gt;&lt;br/&gt;
　　Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择器（Selectors）&lt;/strong&gt;&lt;br/&gt;
　　Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;3 使用场合的选择&lt;/h2&gt;

&lt;p&gt;　　NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。&lt;/p&gt;

&lt;h3&gt;3.1 何时选择NIO&lt;/h3&gt;

&lt;p&gt;　　如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。&lt;/p&gt;

&lt;h3&gt;3.2 何时选择IO&lt;/h3&gt;

&lt;p&gt;　　如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合，而NIO则不太合适。&lt;/p&gt;

&lt;h2&gt;4 完整的NIO示例&lt;/h2&gt;

&lt;h3&gt;4.1 server端&lt;/h3&gt;

&lt;p&gt;通过一个HandleClient来获取文件的一块数据，每一个客户都会分配一个HandleClient的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        package nio.file;

        import java.io.FileInputStream;
        import java.io.IOException;
        import java.net.InetSocketAddress;
        import java.nio.ByteBuffer;
        import java.nio.CharBuffer;
        import java.nio.channels.FileChannel;
        import java.nio.channels.SelectionKey;
        import java.nio.channels.Selector;
        import java.nio.channels.ServerSocketChannel;
        import java.nio.channels.SocketChannel;
        import java.nio.charset.Charset;
        import java.nio.charset.CharsetDecoder;
        import java.util.Iterator;

        /**
         * 测试文件下载的NIOServer
         * 
         * @author tenyears.cn
         */
public class NIOServer {
          static int BLOCK = 4096;
          // 处理与客户端的交互
          public class HandleClient {
            protected FileChannel channel;
            protected ByteBuffer buffer;
            public HandleClient() throws IOException {
              this.channel = new FileInputStream(filename).getChannel();
              this.buffer = ByteBuffer.allocate(BLOCK);
            }
            public ByteBuffer readBlock() {
              try {
                buffer.clear();
                int count = channel.read(buffer);
                buffer.flip();
                if (count &amp;lt;= 0)
                  return null;
              } catch (IOException e) {
                e.printStackTrace();
              }
              return buffer;
            }
            public void close() {
              try {
                channel.close();
              } catch (IOException e) {
                e.printStackTrace();
              }
            }
          }

          protected Selector selector;
          protected String filename = &quot;d://bigfile.dat&quot;; // a big file
          protected ByteBuffer clientBuffer = ByteBuffer.allocate(BLOCK);
          protected CharsetDecoder decoder;

          public NIOServer(int port) throws IOException {
            selector = this.getSelector(port);
            Charset charset = Charset.forName(&quot;GB2312&quot;);
            decoder = charset.newDecoder();
          }

          // 获取Selector
          protected Selector getSelector(int port) throws IOException {
            ServerSocketChannel server = ServerSocketChannel.open();
            Selector sel = Selector.open();
            server.socket().bind(new InetSocketAddress(port));
            server.configureBlocking(false);
            server.register(sel, SelectionKey.OP_ACCEPT);
            return sel;
          }

          // 监听端口
          public void listen() {
            try {
              for (;;) {
                selector.select();
                Iterator&amp;lt;&amp;lt;span style=&quot;background-color: rgb(255, 255, 255); &quot;&amp;gt;SelectionKey&amp;lt;/span&amp;gt;&amp;gt; iter = selector.selectedKeys()
                    .iterator();
                while (iter.hasNext()) {
                  SelectionKey key = iter.next();
                  iter.remove();
                  handleKey(key);
                }
              }
            } catch (IOException e) {
              e.printStackTrace();
            }
          }

          // 处理事件
          protected void handleKey(SelectionKey key) throws IOException {
            if (key.isAcceptable()) { // 接收请求
              ServerSocketChannel server = (ServerSocketChannel) key.channel();
              SocketChannel channel = server.accept();
              channel.configureBlocking(false);
              channel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) { // 读信息
              SocketChannel channel = (SocketChannel) key.channel();
              int count = channel.read(clientBuffer);
              if (count &amp;gt; 0) {
                clientBuffer.flip();
                CharBuffer charBuffer = decoder.decode(clientBuffer);
                System.out.println(&quot;Client &amp;gt;&amp;gt;&quot; + charBuffer.toString());
                SelectionKey wKey = channel.register(selector,
                    SelectionKey.OP_WRITE);
                wKey.attach(new HandleClient());
              } else
                channel.close();
              clientBuffer.clear();
            } else if (key.isWritable()) { // 写事件
              SocketChannel channel = (SocketChannel) key.channel();
              HandleClient handle = (HandleClient) key.attachment();
              ByteBuffer block = handle.readBlock();
              if (block != null)
                channel.write(block);
              else {
                handle.close();
                channel.close();
              }
            }
          }

          public static void main(String[] args) {
            int port = 12345;
            try {
              NIOServer server = new NIOServer(port);
              System.out.println(&quot;Listernint on &quot; + port);
              while (true) {
                server.listen();
              }
            } catch (IOException e) {
              e.printStackTrace();
            }
          }
        } 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.2 client端&lt;/h3&gt;

&lt;p&gt;下面是客户端请求的代码，也比较简单，模拟100个用户同时下载文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nio.file;
        import java.io.IOException;
        import java.net.InetSocketAddress;
        import java.nio.ByteBuffer;
        import java.nio.CharBuffer;
        import java.nio.channels.SelectionKey;
        import java.nio.channels.Selector;
        import java.nio.channels.SocketChannel;
        import java.nio.charset.Charset;
        import java.nio.charset.CharsetEncoder;
        import java.util.Iterator;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;

        /**
         * 文件下载客户端
         * @author tenyears.cn
         */
public class NIOClient {
          static int SIZE = 100;
          static InetSocketAddress ip = new InetSocketAddress(&quot;localhost&quot;,12345);
          static CharsetEncoder encoder = Charset.forName(&quot;GB2312&quot;).newEncoder();
          static class Download implements Runnable {
            protected int index;
            public Download(int index) {
              this.index = index;
            }

            public void run() {
              try {
                long start = System.currentTimeMillis();
                SocketChannel client = SocketChannel.open();
                client.configureBlocking(false);
                Selector selector = Selector.open();
                client.register(selector, SelectionKey.OP_CONNECT);
                client.connect(ip);
                ByteBuffer buffer = ByteBuffer.allocate(8 * 1024);
                int total = 0;
                FOR: for (;;) {
                  selector.select();
                  Iterator&amp;lt;SelectionKey&amp;gt; iter = selector.selectedKeys()
                      .iterator();
                  while (iter.hasNext()) {
                    SelectionKey key = iter.next();
                    iter.remove();
                    if (key.isConnectable()) {
                      SocketChannel channel = (SocketChannel) key
                          .channel();
                      if (channel.isConnectionPending())
                        channel.finishConnect();
                      channel.write(encoder.encode(CharBuffer
                          .wrap(&quot;Hello from &quot; + index)));
                      channel.register(selector, SelectionKey.OP_READ);
                    } else if (key.isReadable()) {
                      SocketChannel channel = (SocketChannel) key
                          .channel();
                      int count = channel.read(buffer);
                      if (count &amp;gt; 0) {
                        total += count;
                        buffer.clear();
                      } else {
                        client.close();
                        break FOR;
                      }
                    }
                  }
                }
                double last = (System.currentTimeMillis() - start) * 1.0 / 1000;
                System.out.println(&quot;Thread &quot; + index + &quot; downloaded &quot; + total
                    + &quot;bytes in &quot; + last + &quot;s.&quot;);
              } catch (IOException e) {
                e.printStackTrace();
              }
            }
          }

          public static void main(String[] args) throws IOException {
            ExecutorService exec = Executors.newFixedThreadPool(SIZE);
            for (int index = 0; index &amp;lt; SIZE; index++) {
              exec.execute(new Download(index));
            }
            exec.shutdown();
          }
        }
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>离职风波</title>
     <link href="http://itweige.com/lizhifengbo"/>
     <updated>2014-06-05T00:00:00+08:00</updated>
     <id>http://itweige.com/lizhifengbo</id>
     <content type="html">&lt;h3&gt;跳槽回忆录：Oracle--&gt;网易&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/blogImages/tiaocao.jpg&quot; alt=&quot;跳槽&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经历了一周的纠结与徘徊之后，终于决定跳了！不管如何，不管会遇到什么阻挠，这次真的是义无反顾了！大不了从头再来，我年轻我怕谁！失业又何妨。。。&lt;/p&gt;

&lt;h4&gt;外企的生活&lt;/h4&gt;

&lt;p&gt;可能真的不适合年轻人，尤其是怀揣着梦想的年轻人。外表轻松，内在无聊，真的学不到真正的技术，核心力量都在美国呢。我们可能做的就是剩下的琐碎的debug和test，无他。&lt;/p&gt;

&lt;h4&gt;跳槽的过程&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;萌芽&lt;/strong&gt;：在外企的两个月每天保持学习，可是拓展的最多是广度，深度上真的无法提升，这也促成了我跳槽想法的萌芽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;准备&lt;/strong&gt;：开始准备面试，每天晚上回去看一些java/jvm方面的较深入知识；写一些技术博客；看算法；看博客；记录博客中技术点，深入百度/google之；亲自动手调制各种软件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;投递&lt;/strong&gt;：准备完成，投简历：搜狗/网易/百度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面试&lt;/strong&gt;：网易彩票get/搜狗web get/百度web lose。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;offer选择&lt;/strong&gt;：最终选择了网易，可能还是面试过程中的技术主管给我留下了深刻印象吧，而且小组内有一个认识的北邮师兄。。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辞职&lt;/strong&gt;：这真是个艰辛的过程，跟manager无数次的谈话，一次两次三次，失败了再谈，谈了再失败，最终第五次的时候摊牌了。。。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;感想&lt;/strong&gt;：真的感想颇多，但是语言组织不是强项，不会表达。反正就是要坚信自己的理想吧，凶狠点，事竟成！为了达到目的真的不能“仁慈”，坚决点！&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;很对不起manager，但是没办法，人各有志，我必须走了！&lt;br/&gt;
很感谢 师兄/2鹏/东升/2超/小强 等小伙伴，在我失落的时候给了我跳槽的勇气和建议，我会努力雄起的！&lt;br/&gt;
&lt;strong&gt;城镇服务性互联网&lt;/strong&gt;，我终将来到！&lt;br/&gt;
&lt;img src=&quot;/images/blogImages/town-network.jpg&quot; alt=&quot;跳槽&quot; /&gt;&lt;br/&gt;
纠结的日子终将过去，此刻感觉很释然。。。&lt;/p&gt;

&lt;p&gt;2014/6/5 15:57:58 &lt;br/&gt;
By Masterwind&lt;br/&gt;
你好，北京&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>逐个击破之--Java Concurrent包</title>
     <link href="http://itweige.com/Java-Concurrent"/>
     <updated>2014-05-29T00:00:00+08:00</updated>
     <id>http://itweige.com/Java-Concurrent</id>
     <content type="html">&lt;h2&gt;背景&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;　　java.util.concurrent 包含许多线程安全、测试良好、高性能的并发构建块。可以说：&lt;strong&gt;创建 java.util.concurrent 的目的就是要实现 Collection 框架对数据结构所执行的并发操作&lt;/strong&gt;。通过提供一组可靠的、高性能并发构建块，开发人员可以提高并发类的线程安全、可伸缩性、性能、可读性和可靠性。&lt;br/&gt;
　　感谢Java并发大师：&lt;strong&gt;Doug Lea&lt;/strong&gt;!&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;1. 并发介绍&lt;/h2&gt;

&lt;p&gt;JDK 5.0 中的并发改进可以分为三组：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JVM 级别更改&lt;/strong&gt; : 大多数现代处理器对并发对某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。&lt;strong&gt;这些更改主要由 JDK 库类使用，而不是由开发人员使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低级实用程序类 -- 锁定和原子类&lt;/strong&gt; : 使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级实用程序类&lt;/strong&gt; : 这些类实现并发构建块，每个计算机科学文本中都会讲述这些类 -- 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多（如果不是全部）同步、wait() 和 notify() 的使用，从而提高性能、可读性和正确性。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　本文将重点介绍 java.util.concurrent 包提供的高级实用程序类,其中包括：线程安全集合、线程池和同步实用程序。这些是初学者和专家都可以使用的&quot;现成&quot;类。&lt;strong&gt;java.util.concurrent 规范进程的一个目标就是提供一组线程安全的、高性能的并发构建块，从而使开发人员能够减轻一些编写线程安全类的负担。&lt;/strong&gt;
在介绍concurrent包之前先看一下jdk中需要了解的包截图（推荐边看源码，边学习）：&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/java-concurrent-packege.png&quot; alt=&quot;JDK包截图&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1.1 java.util集合&lt;/h3&gt;

&lt;p&gt;　　java.util包对应java所有的collection集合，JDK 1.2 中引入的 Collection 框架是一种表示对象集合的高度灵活的框架，它使用基本接口 List、Set 和 Map。通过 JDK 提供每个集合的多次实现（HashMap、Hashtable、TreeMap、WeakHashMap、HashSet、TreeSet、Vector、ArrayList、LinkedList 等等）。其中一些集合已经是线程安全的（Hashtable 和 Vector），通过同步的封装工厂（Collections.synchronizedMap()、synchronizedList() 和 synchronizedSet()），其余的集合均可表现为线程安全的。&lt;br/&gt;
　　java.util 中的线程集合仍有一些缺点。其中的“貌似线程安全集合”（如Hashtable,Vector等），如果没有任何线程在读取，则支持使用多个并发进程写入。&lt;strong&gt;但是：如果使用一个或多个读取器以及一个或多个编写器，则同步包装不提供线程安全的访问。java.util 包中的集合类都返回 fail-fast 迭代器，这意味着它们假设线程在集合内容中进行迭代时，集合不会更改它的内容&lt;/strong&gt;。如果 fail-fast 迭代器检测到在迭代过程中进行了更改操作，那么它会抛出 ConcurrentModificationException，这是不可控异常，此时这些“貌似线程安全集合”就变成了线程不安全集合。&lt;/p&gt;

&lt;h3&gt;1.2 java.util.concurrent&lt;/h3&gt;

&lt;p&gt;　　java.util.concurrent 包添加了多个新的线程安全集合类（ConcurrentHashMap、CopyOnWriteArrayList 和 CopyOnWriteArraySet）。这些类的目的是提供高性能、高度可伸缩性、线程安全的基本集合类型版本。&lt;br/&gt;
　　java.util.concurrent 集合返回的迭代器称为弱一致的（weakly consistent）迭代器。对于这些类，如果元素自从迭代开始已经删除，且尚未由 next() 方法返回，那么它将不返回到调用者。如果元素自迭代开始已经添加，那么它可能返回调用者，也可能不返回。在一次迭代中，无论如何更改底层集合，元素不会被返回两次。&lt;br/&gt;
　　&lt;strong&gt;在 JDK 5.0 之前，确保线程安全的主要机制是 synchronized 原语。访问共享变量（那些可以由多个线程访问的变量）的线程必须使用同步来协调对共享变量的读写访问。java.util.-concurrent 包提供了一些备用并发原语，以及一组不需要任何其他同步的线程安全实用程序类。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2. 详解Concurrent--CopyOnWriteArrayList&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;我们都知道，可以用两种方法创建线程安全支持数据的 List：&lt;br/&gt;
1. Vector&lt;br/&gt;
2.Collections.synchronizedList()封装一个list。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;2.1 为何vector不够安全？&lt;/h3&gt;

&lt;p&gt;　　在java.util.concurrent 包中添加了名称繁琐的 &lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;。为什么我们想要新的线程安全的List类？为什么Vector还不够？&lt;br/&gt;
　　最简单的答案是与迭代和并发修改之间的交互有关。使用 Vector 或使用同步的 List 封装器，返回的迭代器是 fail-fast 的，这意味着如果在迭代过程中任何其他线程修改 List，迭代可能失败。&lt;strong&gt;也就是说在读的同时不能对集合本身进行操作（如添加，修改等）。&lt;/strong&gt;&lt;br/&gt;
　　Vector 的非常普遍的应用程序是存储通过组件注册的监听器的列表。当发生适合的事件时，该组件将在监听器的列表中迭代，调用每个监听器。为了防止 ConcurrentModificationException，迭代线程必须复制列表或锁定列表，以便进行整体迭代，而这两种情况都需要大量的性能成本。那么怎么解决这种并发问题呢？这也就就引出了CopyOnWriteArrayList来解决此类问题。&lt;/p&gt;

&lt;h3&gt;2.2 CopyOnWriteArrayList的引入&lt;/h3&gt;

&lt;p&gt;　　CopyOnWriteArrayList 类通过每次添加或删除元素时创建支持数组的新副本，避免了这个问题，但是进行中的迭代保持对创建迭代器时的本体进行操作。虽然复制也会有一些成本，但是在许多情况下，迭代要比修改多得多，在这些情况下，写入时复制要比其他备用方法具有更好的性能和并发性。如果应用程序需要 Set 语义，而不是 List，那么还有一个 Set 版本 -- CopyOnWriteArraySet。&lt;br/&gt;
　　&lt;strong&gt;这些集合在读的时候跟普通集合一样不加锁&lt;/strong&gt;，在修改集合操作（如写，删）等时，则会用lock拿到当前集合的集合锁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final ReentrantLock lock = this.lock;
lock.lock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　拿到集合锁之后，此时互斥的只是其他的写操作，而读操作不受任何影响可以并发同时进行。下面是一个其中的方法供参考：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public E set(int index, E element) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            E oldValue = get(elements, index);
            if (oldValue != element) {
                int len = elements.length;
                Object[] newElements = Arrays.copyOf(elements, len); //要先进行原数组的拷贝，这样读操作可以在原数组上进行，写操作在拷贝上进行
                newElements[index] = element;
                setArray(newElements);
            } else {
                // Not quite a no-op; ensures volatile write semantics
                setArray(elements);
            }
            return oldValue;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.3 Vector与CopyOnWriteArrayList的比较&lt;/h3&gt;

&lt;p&gt;　　前者因为使用Synchronized修饰了所有内部方法，所以读和写只能某一时刻只有一个线程来执行。而后者允许多个读操作同时进行，且允许同时有一个写操作进行，因为写操作是在数组的副本上进行的，只有写操作互斥，与读操作不互斥。且Vector可能会发生ConcurrentModificationException，而后者不会。&lt;/p&gt;

&lt;h2&gt;3. 详解Concurrent--ConcurrentHashMap&lt;/h2&gt;

&lt;p&gt;　　正如已经存在线程安全的 List 的实现，您可以用多种方法创建线程安全的、基于 hash 的 Map -- Hashtable，并使用 Collections.synchronizedMap() 封装 HashMap。JDK 5.0 添加了 ConcurrentHashMap 实现，该实现提供了相同的基本线程安全的 Map 功能，但它大大提高了并发性。&lt;br/&gt;
　　Hashtable 和 synchronizedMap 所采取的获得同步的简单方法（同步 Hashtable 中或者同步的 Map 封装器对象中的每个方法）有两个主要的不足:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，Hashtable 和 Collections.synchronizedMap 通过同步每个方法获得线程安全。这意味着当一个线程执行一个 Map 方法时，无论其他线程要对 Map 进行什么样操作，都不能执行，直到第一个线程结束才可以。&lt;/li&gt;
&lt;li&gt;同时，这样仍不足以提供真正的线程安全性，许多公用的混合操作仍然需要额外的同步。虽然诸如 get() 和 put() 之类的简单操作可以在不需要额外同步的情况下安全地完成，但还是有一些公用的操作序列，例如迭代或者 put-if-absent（空则放入），需要外部的同步，以避免数据争用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　对比来说，当多个线程需要访问同一Map 时，ConcurrentHashMap可以获得更高的并发性。&lt;br/&gt;
　　&lt;strong&gt;ConcurrentHashMap允许多个读操作并发进行，读操作并不需要加锁:&lt;/strong&gt;如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static final class HashEntry&amp;lt;K,V&amp;gt; {  
    final K key;  
    final int hash;  
    volatile V value;  
    final HashEntry&amp;lt;K,V&amp;gt; next;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。&lt;br/&gt;
　　&lt;strong&gt;ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术:&lt;/strong&gt;它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。&lt;strong&gt;只要多个修改操作发生在不同的段上，它们就可以并发进行。&lt;/strong&gt;&lt;br/&gt;
　　在大多数情况下，ConcurrentHashMap 是 Hashtable或 Collections.synchronizedMap-(new HashMap()) 的简单替换。然而，其中有一个显著不同，即 ConcurrentHashMap 实例中的同步不锁定映射进行独占使用。实际上，没有办法锁定 ConcurrentHashMap 进行独占使用，它被设计用于进行并发访问。为了使集合不被锁定进行独占使用，还提供了公用的混合操作的其他（原子）方法，如 put-if-absent。ConcurrentHashMap 返回的迭代器是弱一致的，意味着它们将不抛出ConcurrentModificationException。可以通过下图说明：&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/Java-hashMap-concurrentHashMap.jpg&quot; alt=&quot;JDK包截图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ConcurrentHashMap的源码可以自行查看JDK源码，有点麻烦，这里就不举例了～。～关于其实现细节可以参考：
&lt;a href=&quot;http://www.iteye.com/topic/344876&quot; title=&quot;ConcurrentHashMap之实现细节&quot;&gt;ConcurrentHashMap之实现细节&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;4.详解Concurrent--线程池ThreadPoolExecutor&lt;/h2&gt;

&lt;p&gt;关于线程池的讲解已经在前面的文章中给出了：&lt;a href=&quot;http://itweige.com/Java-Thread/&quot; title=&quot;伟哥教你破解--Java线程谜团&quot;&gt;伟哥教你破解--Java线程谜团&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;5. 详解Concurrent.locks--ReentrantLock&lt;/h2&gt;

&lt;p&gt;　　ReentrantLock 是具有与隐式监视器锁定（使用 synchronized 方法和语句访问）相同的基本行为和语义的 Lock 的实现，但它具有扩展的能力。&lt;br/&gt;
　　作为额外收获，在竞争条件下，ReentrantLock 的实现要比现在的 synchronized 实现更具有可伸缩性。（有可能在 JVM 的将来版本中改进 synchronized 的竞争性能。）&lt;br/&gt;
　　&lt;strong&gt;这意味着当许多线程都竞争相同锁定时，使用 ReentrantLock 的吞吐量通常要比 synchronized好&lt;/strong&gt;。换句话说，当许多线程试图访问 ReentrantLock 保护的共享资源时，JVM 将花费较少的时间来调度线程，而用更多个时间执行线程。&lt;br/&gt;
　　虽然 ReentrantLock 类有许多优点，但是与同步相比，它有一个主要缺点 -- 它可能忘记释放锁定。建议当获得和释放 ReentrantLock 时使用下列结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Lock lock = new ReentrantLock();
...
lock.lock();
try {
  // perform operations protected by lock
}
catch(Exception ex) {
 // restore invariants
}
finally {
  lock.unlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　因为锁定失误（忘记释放锁定）的风险，所以对于基本锁定，强烈建议您继续使用 synchronized，除非真的需要 ReentrantLock 额外的灵活性和可伸缩性。&lt;br/&gt;
　　ReentrantLock 是用于高级应用程序的高级工具 -- 有时需要，但有时用原来的方法就很好。几乎 java.util.concurrent 中的所有类都是在 ReentrantLock 之上构建的，ReentrantLock 则是在原子变量类的基础上构建的。所以，虽然仅少数并发专家使用原子变量类，但 java.util.concurrent 类的很多可伸缩性改进都是由它们提供的。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>如何快速搭建流媒体服务器</title>
     <link href="http://itweige.com/streamMedia-server"/>
     <updated>2014-05-21T00:00:00+08:00</updated>
     <id>http://itweige.com/streamMedia-server</id>
     <content type="html">&lt;p&gt;　　在之前的一文中介绍了关于流媒体及flv的相关知识：&lt;strong&gt;&lt;a href=&quot;http://itweige.com/flv-stream-media/&quot;&gt;流媒体及FLV定点播放浅析&lt;/a&gt;&lt;/strong&gt;，本文将手把手带来如何实现一个基于flv格式视频的流媒体服务器。&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/streamServer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;FLV视频发布方式&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3&gt;HTTP和RTMP方式简介&lt;/h3&gt;

&lt;p&gt;　　现在网络上的视频网站youtube，6rooms和56，发现他们用的播放协议也都是Http(&lt;strong&gt;这个可以用chrome插件或者firebug观察到&lt;/strong&gt;)。按说FMS/Red5作为流媒体服务器，是专门做过优化的。但为何这些网站都没采用RTMP 的协议呢。RTMP 协议和Http比有哪些优势呢，或者说：我们为什么要使用FMS/Red5呢？&lt;br/&gt;
　　两种协议HTTP和RTMP ，有一些不同：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP方式&lt;/strong&gt;：先通过网络将FLV下载到本地缓存（例如youku是默认存放缓存在：C:\Users\xxx用户名\Documents\Youku Files\transcode中，其中的.dat文件就是加密后的视频缓存文件），然后再通过NetConnection的本地连接来播放这个FLV，这种方法是播放本地的视频，并不是播放服务器的视频，因此在本地缓存里可以找到这个FLV。其优点就是服务器下载完这个FLV，服务器就没有消耗了，节省服务器消耗。其缺点就是FLV会缓存在客户端，对FLV的保 密性不好（利用dat格式文件可以有效缓解这种问题）。HTTP的视频协议，主要是在互联网普及之后。在互联网上看视频的需求下形成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RTMP方式&lt;/strong&gt;：通过NetConnection连接到FMS/Red5服务器，并实时播放服务器的FLV文件，这种方式可以任意选择视频播放点（SEEK()），并不象HTTP方式需要缓存完整个FLV文件到本地才可以任意选择播放点。其优点就是FLV不会缓存在客户端，FLV的保密性好，其缺点就是消耗服务器资源，连接始终是实时的。&lt;br/&gt;
　一句话，一个是本地播放，一个是服务器实时播放，因需而定。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HTTP方式变更史&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最初的HTTP视频协议，没有任何特别之处，就是通用的HTTP文件渐进式下载&lt;/strong&gt;。本质就是下载视频文件，而利用视频文件本身的特点，就是存在头部信息，和部分视频帧数据，就完全可以解码播放了。显然这种方式需要将视频文件的头部信息放在文件的前面。有些例如faststart工具，就是专门做这个功能的。但是最为原始的状态下，视频无法进行快进或者跳转播放到文件尚未被下载到的部分。这个时候对HTTP协议提出了range-request的要求。这个目前几乎所有HTTP的服务器都支持了。range-request，是请求文件的部分数据，指定偏移字节数。在视频客户端解析出视频文件的头部后，就可以判断后续视频相应的帧的位置了。或者根据码率等信息，计算相应的为位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持HTTP range-request的服务器&lt;/strong&gt;，目前就可以支持我们一般网络看视频的要求了。但是，这种方式，无法支持实时视频流，或者准实时视频流。因为视频流，是不存在一个视频文件的概念的。HTTP协议播放视频的好处，就是简单。采取通用的HTTP服务器，就可以提供服务，不需要专门类型的服务器，也不需要特别的网络端口，穿过路由器防火墙一点都没有问题。而且还可以利用通用的CDN来简化视频的部署分发的工作，减少带宽的使用。&lt;strong&gt;这个是目前用于PC端或者网页端，视频点播业务，最常见的解决方案&lt;/strong&gt;。客户端的实现，一般采用flash完成，flash本是的videoplayer或者videodisplay控件就可以完成。资源一般采用flv格式，也可以使用mp4格式。在此基础上，多家公司推出了自己的解决方法。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HTTP方式和RTMP方式比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;rtmp从协议实现来讲需要一定的客户端上行流量，而http则小得多，因此在网络环境不佳的条件下其性能不如http；&lt;/li&gt;
&lt;li&gt;rtmp虽然有服务器端开源实现，但是其性能和强度终究不如FMS，例如用于非关键帧seek的Enhanced Seeking和多码流带宽自适应特性等功能由服务器端实现，其协议细节并未公开；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外rtmp方案也无法覆盖iOS/Andriod等移动设备。&lt;/p&gt;

&lt;p&gt;  综合部署成本，复杂度和普适性考虑，对于常规直播点播应用，HTTP方案优于RTMP方案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;开始搭建流媒体服务器&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;　　了解了上述知识背景，下面开始进行服务器的搭建，本服务器的架构将是：&lt;strong&gt;Jwplayer+Red5+Nginx+RTMP&lt;/strong&gt;,其中前端播放器采用了Adobe 开源播放器Jwplayer，流媒体服务器采用Red5，传输协议RTMP。（其实Nginx服务器也是一款不错的选择，其既可以进行流媒体服务，还可以提供负载均衡/反向代理/缓存等多种服务，可惜本文只提供流媒体服务，故采用Red5这款开源服务器。）&lt;br/&gt;
　　利用red5，自动为其目录下的每个flv文件生成filename.meta的xml信息文件（文件第一次播放时自动产生，所以第一次播放会有一些延迟时间用来产生meta文件，是不是可以实现meta文件提前generate呢？比如在文件放入目录后，服务器端有一个进程轮询查询，查询到新的文件进入，提前先产生meta文件），其中包含了flv视频的关键帧，用于seek操作。&lt;/p&gt;

&lt;h3&gt;前端播放器配置&lt;/h3&gt;

&lt;p&gt;jwplayer的用法很简单，自行百度，此处给出一个配置样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var videoStreamer=&#39;rtmp://172.16.90.238:1935/vod/&#39;;//流媒体服务地址
var player = jwplayer(&#39;videoDiv&#39;).setup( {
  width : &quot;100%&quot;,
  height : 280,
  flashplayer : &#39;jwplayer/pl.swf&#39;,
  image : &#39;images/roadPreview.jpg&#39;,
  controlbar : &#39;bottom&#39;,
  file : &quot;red5&quot;,//媒体文件根目录
  provider : &#39;rtmp&#39;,//传输协议
  streamer : videoStreamer//配置服务地址
 });

player.load( [ {
   file : videoUrl//可以通过这种方式更换视频地址，注意不是服务地址
  } ]);
player.play();//开始播放
player.seek(preVideoTime);//根据时间，进行seek地位播放
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Red5服务器配置&lt;/h3&gt;

&lt;p&gt;　　利用red5，自动为其目录下的每个flv文件生成filename.meta的xml信息文件（文件第一次播放时自动产生，所以第一次播放会有一些延迟时间用来产生meta文件，是不是可以实现meta文件提前generate呢？比如在文件放入目录后，服务器端有一个进程轮询查询，查询到新的文件进入，提前先产生meta文件），其中包含了flv视频的关键帧，用于seek操作。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://red5.org/downloads/red5/1_0/&quot;&gt;Red5下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.red5.org/downloads/docs/&quot;&gt;安装说明文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在开启Red5前，需首先查看1935端口是否被占用，Windows下查看当前服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#查看当前系统被占用的端口  
netstat –ano –p tcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果Red5的默认端口1935被占用了，可以为其配置新的端口号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#设置为一个未被其他进程占用的端口，今后流媒体client都通过此端口请求流媒体数据
rtmp.port=1936
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用Red5搭建流媒体服务器时，需要配置其对外提供流媒体的IP（文档位置Red5/conf/ red5.properties）：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#本地通过localhost:port方式访问时，使用此配置。（与下面的配置二选一）
rtmp.host=127.0.0.1
#远程/实际应用场景中通过 IP:port方式访问时，使用此配置。（将下一行#去掉，即生效）
#rtmp.host=10.210.46.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[NOTE]：&lt;strong&gt;如果上述rtmp.host配置的IP地址，与服务器上实际获取的IP不同，则Red5服务无法正常开启。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Red5提供的功能很强大，在提供流媒体服务的同时，还开启了自带的Tomcat，同样需要注意将Tomcat的端口配置为一个未占用的端口。（文档位置Red5/conf/ red5.properties）　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#配置Red5自带的Tomcat服务。
http.port=8888
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Red5流媒体服务器：
直接运行Red5安装路径下的red5.bat文件，当出现如下信息时，表示已经成功启动Red5流媒体服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[INFO] [Launcher:/installer] org.red5.server.service.Installer - Installer service created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Red5提供流媒体服务，即，可以将其上存储的视频数据，以可控的数据流形式，向外提供服务。通常将需要对外提供的原始视频数据，存放于如下位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Red5/webapps/vod/streams/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：本节内容从ningg大神那里学到的，这里只是引用，班门弄斧了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;搭建完成，此时就实现了一个基于RTMP协议和FLV格式视频文件的流媒体服务器搭建。&lt;br/&gt;
上一个我们开发的项目视频播放展示图:&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/stream-server-show.png&quot; alt=&quot;展示图&quot; /&gt;&lt;br/&gt;
更好的优化方案，有待继续深入研究～。～&lt;/p&gt;

&lt;p&gt;最后附RTMP协议详解：
&lt;a href=&quot;http://blog.csdn.net/defonds/article/details/17403225&quot;&gt;实时消息传输协议 RTMP(Real Time Messaging Protocol)&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>初探Nodejs</title>
     <link href="http://itweige.com/Nodejs-rookie"/>
     <updated>2014-05-21T00:00:00+08:00</updated>
     <id>http://itweige.com/Nodejs-rookie</id>
     <content type="html">&lt;p&gt;初探nodejs，占个坑位，这两天浅浅学习下，过两天补上学习内容。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>javascript面向对象编程浅析</title>
     <link href="http://itweige.com/javascript-oop"/>
     <updated>2014-05-20T00:00:00+08:00</updated>
     <id>http://itweige.com/javascript-oop</id>
     <content type="html">&lt;h3&gt;什么是面向对象&lt;/h3&gt;

&lt;p&gt;面向对象最基本的三大特性是继承、封装、多态，javascript不是面向对象的语言，但能实现继承和封装两个特性。&lt;/p&gt;

&lt;h3&gt;弱类型&lt;/h3&gt;

&lt;p&gt;定义变量类型：&lt;/p&gt;

&lt;p&gt;布尔型bool、数值型、字符串类型、函数类型、数组类型、空类型、未定义类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &quot;&quot;; //字符串
var b = []; //数组
var c = function(){} //function函数
var d = {}; //对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面量:&lt;/p&gt;

&lt;p&gt;字面量就类似于我们使用的json数据格式，分为字符串字面量、数组字面量、函数字面量、对象字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cat = {
    //字符串字面量
    name : &quot;cat&quot;,

    //数组字面量
    type : [&quot;波斯猫&quot;, &quot;加菲猫&quot;, &quot;垂耳猫&quot;],

    //函数字面量
    mark : function(){alert(this.name + this.type)},

    //对象字面量
    info : {from : &quot;usa&quot;, &quot;age&quot; : &quot;1&quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建js对象&lt;/h3&gt;

&lt;p&gt;js对象只是一组名称/值对，可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，像词典。&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = new Object();
userObject.lastLoginTime = new Date();
alert(userObject.lastLoginTime); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = {}; // equivalent to new Object()
userObject[&quot;lastLoginTime&quot;] = new Date();
alert(userObject[&quot;lastLoginTime&quot;]);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = { 
    &quot;lastLoginTime&quot; : new Date() 
};
alert(userObject.lastLoginTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建js函数，函数也是对象&lt;/h3&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、普通函数
function func(x) {
    alert(x);
}
func(&quot;blah&quot;);

//2、定义函数，在此创建函数对象，并赋给变量func
var func = function(x) {
    alert(x);
};
func(&quot;blah2&quot;);

//3、用Funciton构造函数，不常用
var func = new Function(&quot;x&quot;, &quot;alert(x);&quot;);
func(&quot;blah3&quot;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用对象初始化器创建对象&lt;/h3&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myConstructor = function(){
}

//添加静态属性
//name属性和alertName()方法作为静态成员添加到了对象实例中
myConstructor.name = &quot;heiniu&quot;;
myConstructor.alertName = function(){
    alert(this.name);
}
//执行,不需要new
myConstructor.alertName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：等价于以下代码，结构更简洁清晰。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//name属性和alertName()方法作为静态成员添加到了对象实例中
var myConstructor = {
    //静态属性
    name : &quot;heiniu&quot;,

    //静态方法
    alertName : function(){
        alert(this.name);
    }
}

//执行,不需要new
myConstructor.alertName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点：简洁明了；&lt;/li&gt;
&lt;li&gt;缺点：创建对象的代码是一次性的&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;使用构造函数创建对象&lt;/h3&gt;

&lt;p&gt;定义构造函数，而不是类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//私有成员就是在构造函数中定义的变量和函数
function myConstructor2(msg, name){

    //公有属性
    this.myMsg = msg;
    this.name = name;

    //私有属性
    var myVersion = &quot;1.0&quot; 

    //私有方法
    function alertMsg(){
        alert(this.myMsg)
        alert(myVersion)
    }
    alertVersion();//实例化时显示信息

    //特权方法，也是公用方法，在构造函数的作用域中使用this关键字定义的方法，尽量不要用，只用于需要访问私有成员的情况。
    this.appendToMsg = fucntion(string){
        this.myMsg += &quot;heiniu_&quot; + string;
        alertMsg();
    }

}

//静态属性和方法，静态成员是直接通过类对象访问的。
myConstructor2.myYear = &quot;2012&quot;;
myConstructor2.now = function(){
    return new Date();
}

//公有方法，修改函数原型，即prototype属性。
//一旦修改原型方法则立即应用到继承的对象和实例中，有风险。
//原型方式会将新方法添加到myConstructor2的底层定义中，而不是myConstructor2实例自身。
myConstructor2.prototype.alertMsg(){
    alert(this.myMsg);
}
myConstructor2.prototype.alertName(){
    alert(this.name);
}

var myObj = new myConstructor2(&quot;hello&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new操作符等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、call()方法,每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。第一个参数用作 this 的对象。其他参数都直接传递给函数自身。
var myObj = {};
myConstructor2.call(myObj,&quot;hello&quot;, &quot;heiniu&quot;)

//2、apply()方法，有两个参数，用作 this 的对象和要传递给函数的参数的数组。
var myObj = {};
myConstructor2.apply(myObj,[&quot;hello&quot;, &quot;heiniu&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;call的工作机制：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someuser = {
    name : &quot;sjm&quot;,
    display : function(words){
        console.log(this.name + &#39; says &#39; + words);
    }
};

var myself = {
    name : &quot;heiniu&quot;
};

someuser.display.call(myself, &#39;fighting!&#39;);
//结果：heiniu says fighting!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;someuser.display是函数的引用，即被调用的函数。&lt;/li&gt;
&lt;li&gt;myself是someuser.display被调用时的上下文对象。&lt;/li&gt;
&lt;li&gt;&#39;fighting!&#39;是传入someuser.display的参数。&lt;/li&gt;
&lt;li&gt;通过call将上下文对象改变为myself对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。&lt;/p&gt;

&lt;p&gt;call和apply的功能一致：以不同的对象作为上下文来调用某个函数，即允许一个对象去调用另一个对象的成员函数。&lt;/p&gt;

&lt;p&gt;call和apply的差别：call以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。&lt;/p&gt;

&lt;p&gt;使用不同的引用来调用同一个函数时，this指针永远是这个引用所属的对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点：可创建出多个规划好的对象，有若干个固定的属性、方法，并能初始化实例化。&lt;/li&gt;
&lt;li&gt;缺点：复杂些，有上下文对象（this指针），即被调用函数所处的环境。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;使用原型和构造函数共同生成对象&lt;/h3&gt;

&lt;p&gt;什么是原型链？&lt;/p&gt;

&lt;p&gt;继承方面,javascript中的每个对象都有一个内部私有的链接指向另一个对象 (或者为 null),这个对象就是原对象的原型. 这个原型也有自己的原型, 直到对象的原型为null为止. 这种一级一级的链结构就称为原型链.&lt;/p&gt;

&lt;p&gt;prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ClassA() {
}

ClassA.prototype.color = &quot;blue&quot;;
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

//继承和扩展
ClassB.prototype = new ClassA();
ClassB.prototype.name = &quot;&quot;;
ClassB.prototype.sayName = function () {
    alert(this.name);
};

//执行
var objA = new ClassA();
var objB = new ClassB();
objA.color = &quot;blue&quot;;
objB.color = &quot;red&quot;;
objB.name = &quot;John&quot;;
objA.sayColor();
objB.sayColor();
objB.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用原型与直接在构造函数内定义的属性 不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构造函数内定义的属性继承方式与原型不同，子对象需要显示调用父对象才能继承构造函数内定义的属性。&lt;/li&gt;
&lt;li&gt;构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。&lt;/li&gt;
&lt;li&gt;构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说是可见的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;原型使用场合：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;除非必须用构造函数闭包，否则尽量用原型定义成员函数，可减少开销&lt;/li&gt;
&lt;li&gt;尽量在构造函数内定义一般成员，尤其是对象或数组，因为用原型定义的成员是多个实例共享的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;原型链机制：&lt;/h3&gt;

&lt;p&gt;javascript分为三类对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、用户创建的对象&lt;/li&gt;
&lt;li&gt;2、构造函数对象&lt;/li&gt;
&lt;li&gt;3、原型对象&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo(){
}
var foo = new Foo();
var obj = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;公有、私有、特权、静态总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;私有和特权成员在函数的内部，他们会被带到函数的每一个实例中生成新的副本，因而将占用大量的内存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;公有的原型成员是对象的一部分，适用于通过new关键字实例化该对象的每一个实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态成员所关联的是类本身，而不同的是大多数方法和属性所关联的是类的实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;私有成员命名规范上用下划线表示，私有成员可避免安全隐患，防止使用者修改某个属性，导致对象内部数据的一致性受到破坏。如&lt;code&gt;_myPrivateProp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&quot;&gt;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&quot;&gt;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>深夜杂念：程序人生</title>
     <link href="http://itweige.com/programmer-thoughts"/>
     <updated>2014-05-17T00:00:00+08:00</updated>
     <id>http://itweige.com/programmer-thoughts</id>
     <content type="html">&lt;h3&gt;夜深人静，思绪静下来，总结一下今天的程序人生见闻和思考，留作日后备注：&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/blogImages/programmer.jpg&quot; alt=&quot;程序员&quot; /&gt;&lt;/p&gt;

&lt;p&gt;记录几点有意义的心得：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所谓专家，就是在一个有限的领域里，把所有的错误都犯过一次。&lt;/li&gt;
&lt;li&gt;和提高技术能力同等重要的是，深入学习、理解自己所在的行业，理解产业链的上下游、公司的运营方式、产品的赢利模式。&lt;/li&gt;
&lt;li&gt;但管努力，莫问前程。&lt;/li&gt;
&lt;li&gt;动手永远高于理念，看100本系统架构书不如自己去亲手搭一遍来的实在。&lt;/li&gt;
&lt;li&gt;还有就是我真的想去 &lt;strong&gt;百度/小米&lt;/strong&gt; 这种公司挑战下自己了,外企的生活对于年轻人就是美丽的“围城”。&lt;/li&gt;
&lt;li&gt;木桶效应：周围木桶板的高度决定了你对木桶存在的价值。&lt;/li&gt;
&lt;li&gt;很多时候，半途而废的背后就是只差一步，要坚持；克服问题，不退缩。&lt;/li&gt;
&lt;li&gt;要有“说做就做”的勇气。&lt;/li&gt;
&lt;li&gt;但如果要开发一些底层的软件，大型的系统的时候，就必须用到C、C++、汇编等开发语言，这是成功尖端人才的一个条件。&lt;/li&gt;
&lt;li&gt;《计算机操作系统》这本书真是个经典。&lt;/li&gt;
&lt;li&gt;日三省乎己：每日睡觉失眠的时候，掏出云笔记反省下今日学到的东西。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身体是革命的本钱。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;
明天买的200多块钱的书要到了，又可以恶补一番了～。～  &lt;br/&gt;
时间不早了，晚安北京。&lt;strong&gt;May 17 2014 1:55 AM&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后推荐一篇博文，关于web系统开发的文章：&lt;br/&gt;
&lt;a href=&quot;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before&quot;&gt;What technical details should a programmer of a web application consider before making the site public?&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>伟哥教你破解--Java线程谜团</title>
     <link href="http://itweige.com/Java-Thread"/>
     <updated>2014-05-15T00:00:00+08:00</updated>
     <id>http://itweige.com/Java-Thread</id>
     <content type="html">&lt;h2&gt;Thread类--关键方法&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Thread类的关键方法有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;yield()&lt;/strong&gt;   ：让出cpu使用权，但是马上进入可执行状态，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sleep(time)&lt;/strong&gt; ：交出cpu使用权，进入限时等待状态，过了time之后重新进入可执行状态。 作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start()&lt;/strong&gt;  ：线程启动，变为可执行状态，也叫就绪状态;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;run()&lt;/strong&gt; ：进入执行状态;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stop()&lt;/strong&gt; :结束，进入死亡状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interrupt()&lt;/strong&gt; ：interrupt对于一个线程，标示着它应该停下它正在做的事情来做些其他的。具体的是由程序员来决定一个线程如何回应interrupt，一般都是让这个线程终止；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;join()&lt;/strong&gt;：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。使用方法：在当前线程A中，有一个B线程的示例线程bt，则在A中执行bt.join()之后，只能等bt执行完才能执行A线程剩下的代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;join(time)&lt;/strong&gt;:跟join()类似，只不过限定了一个时间；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;currentThread()&lt;/strong&gt;:当前正在执行的线程，使用方法如Thread.currentThread().getName()。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Thread状态&lt;/h2&gt;

&lt;p&gt;java中线程主要有5类状态，其中等待/睡眠/阻塞 我在这里归为一类状态，都为等待或者阻塞状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新生状态：刚new出来，还没有run的时候。&lt;/li&gt;
&lt;li&gt;就绪状态：执行了start之后，位于就绪队列中，等待分配cpu执行。&lt;/li&gt;
&lt;li&gt;执行状态：获得到cpu使用权，进入执行状态。&lt;/li&gt;
&lt;li&gt;等待/睡眠/阻塞状态：调用join()/sleep()/wait()或者资源被占用，此时进入阻塞状态。&lt;/li&gt;
&lt;li&gt;死亡状态：就是死了。。。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;线程状态转化图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/projectImage/thread-status.png&quot; alt=&quot;线程状态图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;线程间的关系&lt;/h2&gt;

&lt;p&gt;其实Java中的线程间就存在两大类关系：线程互斥 和 线程同步通信，前者通过synchronized解决，后者通过wait()/notify()/notifyAll()来解决。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程间互斥&lt;/strong&gt;:利用synchronized关键字即可实现，synchronized向jvm申请了一个针对内存对象的锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程间互相唤醒&lt;/strong&gt;: 此时就需要object.wait()和object.notify()了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;其中生产者/消费者模式 就融合了这两种情况，我们一会分析到。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;关于Object类中的wait/notify&lt;/h2&gt;

&lt;p&gt;线程间的同步要用到wait/notify方法，他们在object类中。Java中每个object对象都有一个互斥锁，线程获取到后就形成了互斥操作，wait/notify操作必须在这个互斥的同步区（synchronized块，以object对象为锁）内执行。
object中的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wait()：立即释放对象锁，然后进入等待状态。&lt;/li&gt;
&lt;li&gt;wait(time)：当time时间过去后，就恢复可执行状态了。&lt;/li&gt;
&lt;li&gt;notify()：使得一个waiting状态的线程进入可执行状态。&lt;/li&gt;
&lt;li&gt;notifyAll()：唤醒所以waiting状态的线程。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁的线程进行操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。&lt;/li&gt;
&lt;li&gt;从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。&lt;strong&gt;但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。&lt;/strong&gt;这样就提供了在线程间同步、唤醒的操作。&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;从上面分析来看，wait()和notify()方法都是释放锁，一个是立即释放锁，另一个是等执行完synchronized代码块后在释放锁，同时后者会通知该互斥锁上的一个wait线程进入可执行状态，notifyAll（）的话就是所有该互斥锁上的进程都被唤醒进入可执行状态。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;sleep() wait()的比较&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt; Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制,而sleep则会一直保持它的锁。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;生产者消费者实例&lt;/h2&gt;

&lt;p&gt;生产者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static class Producer implements Runnable { 
        private int start; 
        private int end; 

        Producer(int start, int end) { 
            this.start = start; 
            this.end = end; 
        } 

        @Override 
        public void run() { 
            for (int i = start; i &amp;lt; end; i ++) { 
                synchronized (basket) { 
                    try { 
                        while (basket.size() == capacity) { 
                            basket.wait(); 
                        } 
                        String p = &quot; PRO&quot; + i; 
                        System.out.println(Thread.currentThread().getName() + p); 
                        basket.add(p); 
                        basket.notifyAll(); 
                        Thread.yield(); // 让出当前线程的执行权,有利于看出交替线程运行的效果 
                    } catch (InterruptedException e) { 
                        e.printStackTrace(); 
                        break; 
                    } 
                } 
            } 
        } 
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消费者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; static class Customer implements Runnable { 
        @Override 
        public void run() { 
            while (true) { 
                synchronized (basket) { 
                    try{ 
                        while (basket.size() == 0) { 
                            basket.wait(); 
                        } 
                        System.out.println(Thread.currentThread().getName() + basket.remove(0)); 
                        basket.notifyAll(); 
                    } catch (InterruptedException e) { 
                        System.out.println(Thread.currentThread().getName() + &quot;退出&quot;); 
                        break; 
                    } 
                } 
            } 
        } 
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各位客官注意看wait和notifyAll的用法。&lt;/p&gt;

&lt;h2&gt;线程池&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3&gt;为什么要用线程池:&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。&lt;br/&gt;
2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Java线程池类介绍&lt;/h3&gt;

&lt;p&gt;Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。下面这张图完整描述了线程池的类体系结构：&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/java-threadPool.png&quot; alt=&quot;线程池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java线程池中几个比较重要的类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ExecutorService： 真正的线程池接口。&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService: 和Timer/TimerTask类似，解决那些需要任务重复执行的问题。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor : ExecutorService的默认实现。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;线程池类为 java.util.concurrent.ThreadPoolExecutor，常用构造方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,RejectedExecutionHandler handler) 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;corePoolSize： 线程池维护线程的最少数量&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池维护线程的最大数量&lt;/li&gt;
&lt;li&gt;keepAliveTime： 线程池维护线程所允许的空闲时间&lt;/li&gt;
&lt;li&gt;unit： 线程池维护线程所允许的空闲时间的单位&lt;/li&gt;
&lt;li&gt;workQueue： 线程池所使用的缓冲队列&lt;/li&gt;
&lt;li&gt;handler： 线程池对拒绝任务的处理策略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当一个任务通过execute(Runnable)方法欲添加到线程池时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行）&lt;/li&gt;
&lt;li&gt;如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void execute(Runnable command) {
      if (command == null)
          throw new NullPointerException();
      /*
       * Proceed in 3 steps:
       *
       * 1. If fewer than corePoolSize threads are running, try to
       * start a new thread with the given command as its first
       * task. The call to addWorker atomically checks runState and
       * workerCount, and so prevents false alarms that would add
       * threads when it shouldn&#39;t, by returning false.
       *
       * 2. If a task can be successfully queued, then we still need
       * to double-check whether we should have added a thread
       * (because existing ones died since last checking) or that
       * the pool shut down since entry into this method. So we
       * recheck state and if necessary roll back the enqueuing if
       * stopped, or start a new thread if there are none.
       *
       * 3. If we cannot queue task, then we try to add a new
       * thread. If it fails, we know we are shut down or saturated
       * and so reject the task.
       */
      int c = ctl.get();
      if (workerCountOf(c) &amp;lt; corePoolSize) {
          if (addWorker(command, true))
              return;
          c = ctl.get();
      }
      if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
          int recheck = ctl.get();
          if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
              reject(command);
          else if (workerCountOf(recheck) == 0)
              addWorker(null, false);
      }
      else if (!addWorker(command, false))
          reject(command);
  }  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;分析可得：当新任务到来时，线程池处理优先级：corePollSize&gt;任务队列&gt;maximumPoolSize。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;现成的Java线程池工厂&lt;/h3&gt;

&lt;p&gt;配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在&lt;strong&gt;Executors&lt;/strong&gt;类（上图中，图片右下角这个类）里面提供了一些静态工厂，生成一些常用的线程池：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;newSingleThreadExecutor&lt;/strong&gt;：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newFixedThreadPool&lt;/strong&gt;：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newCachedThreadPool&lt;/strong&gt;：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newScheduledThreadPool&lt;/strong&gt;：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;因为这些方法在Executors类中都是静态方法，所以可以直接通过如下的方法获得到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor threadPool=Executors.newCachedThreadPool();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这差不多就是Java线程里面的全部内容了，大概有个全方位的了解，用于以后的精学，建议配合Jdk源码进行更深入的学习。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>流媒体及FLV定点播放浅析</title>
     <link href="http://itweige.com/flv-stream-media"/>
     <updated>2014-05-13T00:00:00+08:00</updated>
     <id>http://itweige.com/flv-stream-media</id>
     <content type="html">&lt;h2&gt;1. 何谓流媒体&lt;/h2&gt;

&lt;h4&gt;1.1 流媒体概述&lt;/h4&gt;

&lt;p&gt;　　所谓流媒体是指采用流式传输的方式在Internet播放的媒体格式。 流媒体又叫流式媒体，它是指商家用一个视频传送服务器把节目当成数据包发出，传送到网络上。用户通过解压设备对这些数据进行解压后，节目就会像发送前那样显示出来。&lt;br/&gt;
　　流媒体是指以流的方式在网络中传输音频、视频和多媒体文件的形式。 流媒体文件格式是支持采用流式传输及播放的媒体格式。流式传输方式是将视频和音频等多媒体文件经过特殊的压缩方式分成一个个压缩包，由服务器向用户计算机连续、实时传送。在采用流式传输方式的系统中，用户不必像非流式播放那样等到整个文件全部下载完毕后才能看到当中的内容，而是只需要经过几秒钟或几十秒的启动延时即可在用户计算机上利用相应的播放器对压缩的视频或音频等流式媒体文件进行播放，剩余的部分将继续进行下载，直至播放完毕。&lt;br/&gt;
　　流式媒体在播放前并不下载整个文件，只将开始部分内容存入内存，流式媒体的数据流随时传送随时播放，只是在开始时有一些延迟。流媒体实现的关键技术就是流式传输。流式传输定义很广泛，现在主要指通过网络传送媒体（如视频、音频）的技术总称。其特定含义为通过Internet 将影视节目传送到PC机。实现流式传输有两种方法：实时流式传输（Real time streaming）和顺序流式传输（progressive streaming）。一般说来，如视频为实时广播，或使用流式传输媒体服务器，或应用如RTSP的实时协议，即为实时流式传输。如使用HTTP服务器，文件即通过顺序流发送。&lt;/p&gt;

&lt;h4&gt;1.2 流媒体技术&lt;/h4&gt;

&lt;blockquote&gt;&lt;p&gt;所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;1.3 流媒体传输方式&lt;/h5&gt;

&lt;p&gt;　　流媒体传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。&lt;strong&gt;顺序流式传输与实时流式传输的区别&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顺序流式传输是顺序下载，在下载文件的同时用户可观看在线媒体，在给定时刻，用户只能观看已下载的那部分，而不能跳到还未下载的前头部分，顺序流式传输不象实时流式传输在传输期间根据用户连接的速度做调整。由于标准的HTTP服务器可发送这种形式的文件，也不需要其他特殊协议，它经常被称作HTTP流式传输。顺序流式传输比较适合高质量的短片段，如片头、片尾和广告，由于该文件在播放前观看的部分是无损下载的，这种方法保证电影播放的最终质量。这意味着用户在观看前，必须经历延迟，对较慢的连接尤其如此。对通过调制解调器发布短片段，顺序流式传输显得很实用，它允许用比调制解调器更高的数据速率创建视频片段。尽管有延迟，毕竟可让你发布较高质量的视频片段。顺序流式文件是放在标准HTTP或FTP服务器上，易于管理，基本上与防火墙无关。顺序流式传输不适合长片段和有随机访问要求的视频，如：讲座、演说与演示。它也不支持现场广播，严格说来，它是一种点播技术。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时流式传输指保证媒体信号带宽与网络连接配匹，使媒体可被实时观看到。实时流与HTTP流式传输不同，他需要专用的流媒体服务器与传输协议。实时流式传输总是实时传送，特别适合现场事件，也支持随机访问，用户可快进或后退以观看前面或后面的内容。理论上，实时流一经播放就可不停止，但实际上，可能发生周期暂停。实时流式传输必须配匹连接带宽，这意味着在以调制解调器速度连接时图象质量较差。而且，由于出错丢失的信息被忽略掉，网络拥挤或出现问题时，视频质量很差。如欲保证视频质量，顺序流式传输也许更好。实时流式传输需要特定服务器，如：QuickTime Streaming Server、RealServer与Windows Media Server。这些服务器允许你对媒体发送进行更多级别的控制，因而系统设置、管理比标准HTTP服务器更复杂。实时流式传输还需要特殊网络协议，如：RTSP (Realtime Streaming Protocol)或MMS (Microsoft Media Server)。这些协议在有防火墙时有时会出现问题，导致用户不能看到一些地点的实时内容。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1.4 流媒体传输协议&lt;/h4&gt;

&lt;p&gt;　　流媒体的传输需要合适的传输协议，在internet上的文件传输大部分都是建立在tcp协议的基础上，也有一些是以ftp传输协议的方式进行传输，但采用这些传输协议都不能实现实时方式的传输。随着流媒体技术的深入研究，比较成熟的流媒体传输一般都是采用建立在udp协议上的rtp/rtsp实时传输协议。对于对传输质量要求不是很高，而对传输速度则有很高的要求的视音频流媒体文件来说，采用udp协议则更合适．下面，让我们来看一下现在使用的主要的流媒体协议：&lt;br/&gt;
　　1. RTSP（Real Time Streaming Protocol），实时流媒体协议，它是由RealNetworks和Netscape共同提出的，现在用于RealNetworks的Real Media产品中；&lt;br/&gt;
　　2. PNM（Progressive Networks Audio），这也是Real专用的实时传输协议，它一般采用UDP协议，并占用7070端口，但当你的服务器在防火墙内且7070端口被挡，且你的服务器把SmartingNetwork设为真时，则采用http协议，并占用默认的80端口；&lt;br/&gt;
　　3. MMS（Microsoft Media Server protocol），这是微软的流媒体服务器协议，MMS 是连接 Windows Media 单播服务的默认方法。&lt;/p&gt;

&lt;h4&gt;1.5 流媒体包重组排序&lt;/h4&gt;

&lt;p&gt;　　因为internet是以包为单位进行异步传输的，因此多媒体数据在传输中要被分解成许多包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包的现象．为此，必须采用缓存技术来纠正由于数据到达次序发生改变而产生的混乱状况，利用缓存对到达的数据包进行正确排序，从而使视音频数据能连续正确地播放．缓存中存储的是某一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的．流媒体在播放时不断读取缓存中的数据进行播放，播放完后该数据便被立即清除，新的数据将存入到缓存中．因此，在播放流媒体文件时并不需占用太大的缓存空间．&lt;/p&gt;

&lt;h2&gt;2. 详解FLV格式&lt;/h2&gt;

&lt;p&gt;　　FLV 是FLASH VIDEO的简称，FLV流媒体格式是随着Flash MX的推出发展而来的视频格式。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能.当前主流的媒体网站像国内的优酷、国外youtube其标清格式的文件均采用flv的格式。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。&lt;br/&gt;
　　FLV是一个二进制文件，其文件格式如下图 ，由文件头（FLV header）和很多tag组成。tag又可以分成三类：audio,video,script，分别代表音频流，视频流，脚本流（关键字或者文件信息之类）。&lt;br/&gt;
  　　参考链接：  http://wuyuans.com/2012/08/flv-format/&lt;/p&gt;

&lt;h4&gt;2.1 FLV Header&lt;/h4&gt;

&lt;p&gt;　　FLV的Header信息一般比较简单，记录了flv的类型、版本等信息，是flv的开头，一般占9bytes。。如下图中解析：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;/images/projectImage/flv-flvHeader.jpeg&quot; alt=&quot;flv header &quot; /&gt;&lt;br/&gt;
　　文件类型：3bytes 总是FLV（0x46 0x4C 0x56），否则就不是在ffmpeg中在没有指定文件格式的情况下，也是通过这个字段来探测文件是否属于FLV格式的。&lt;br/&gt;
　　版本：1byte 一般是0x01，表示FLV version 1&lt;br/&gt;
　　流信息：1byte 倒数第一bit是1表示有视频，倒数第三bit是1表示有音频，其他都应该是0（有些软件如flvtool2可能造成倒数第四bit是1，不过也没发现有什么不对）&lt;br/&gt;
　　header长度：4bytes 整个文件头的长度，一般是9（3+1+1+4），当然头部字段也有可能包含其它信息这个时间其长度就不是9了。&lt;/p&gt;

&lt;h4&gt;2.2 FLV Body&lt;/h4&gt;

&lt;p&gt;　　body部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间PreViousTagSize，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图：&lt;br/&gt;
   &lt;img src=&quot;/images/projectImage/flv-flvBody.jpeg&quot; alt=&quot;flv header &quot; /&gt;&lt;/p&gt;

&lt;h5&gt;2.2.1 Tag&lt;/h5&gt;

&lt;p&gt;　　每个Tag也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息.&lt;/p&gt;

&lt;h6&gt;2.2.2 Tag Data&lt;/h6&gt;

&lt;p&gt;　　数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。&lt;/p&gt;

&lt;h4&gt;2.3 FLV视频发布方式&lt;/h4&gt;

&lt;p&gt;　　&lt;strong&gt;FLV视频有两种发布方式:HTTP方式和TRMP流媒体方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;2.3.1  HTTP方式&lt;/h5&gt;

&lt;p&gt;　　这种方式要下载FLV视频文件到本地播放，一旦FLV视频文件下载完成，就不会消耗服务器的资源和带宽，但是拖动功能没有RTMP/RTMP流媒体方式强大。&lt;/p&gt;

&lt;h5&gt;2.3.2  RTMP/RTMP流媒体方式&lt;/h5&gt;

&lt;p&gt;　　这种方式不用下载FLV视频文件到本地，可以实时的播放flv文件，可以任意拖拽播放进度条，但是比较消耗服务器的资源，&lt;/p&gt;

&lt;h2&gt;3.关于视频帧&lt;/h2&gt;

&lt;p&gt;　　我们都知道视频是由图片构成的，就像早期的胶片电影一样，一幅幅图片连续播放就形成了视频，在视频中我们管这些图片叫帧。在x264中有三种基本的帧类型：I帧、P帧和B帧.&lt;br/&gt;
　　参考链接：http://blog.163.com/yan_ku@126/blog/static/122375126201210199813425/&lt;/p&gt;

&lt;h4&gt;3.1 I帧&lt;/h4&gt;

&lt;p&gt;　　I帧(I frame)，又称为内部画面(intra picture)，I帧通常是每个GOP(MPEG 所使用的一种视频压缩技术)的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。在MPEG编码的过程中，部分视频帧序列压缩成为I帧；部分压缩成P帧；还有部分压缩成B帧。I帧法是帧内压缩法，也称为“关键帧”压缩法。————百度百科&lt;br/&gt;
　　也就是说I帧其实是图片编码的，类似于JPEG编码，可以理解为电影中的胶片。而且I帧的生成是没有参考前后帧的，他只是作为参考点而存在，其他类型的帧都是以他为原型经过适当编码而来的。&lt;/p&gt;

&lt;h4&gt;3.2 P帧&lt;/h4&gt;

&lt;p&gt;　　前向预测编码帧 又称predictive-frame，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。&lt;br/&gt;
　　P帧是由前面的帧预测而来的，打个比方，I帧就是父母，P帧相当于孩子，孩子还可以再生孩子，一切的起源肯定是父母，也就是I帧。&lt;br/&gt;
  &lt;img src=&quot;/images/projectImage/flv-PFrame.png&quot; alt=&quot;B Frame&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;3.3 B帧&lt;/h4&gt;

&lt;p&gt;　　双向预测内插编码帧 又称bi-directional interpolated prediction frame 。B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。&lt;br/&gt;
　　一般视频的帧率为23，有的甚至到了30，也就是说一秒钟有23帧的画面，除非那部电影的场面相当动作，不然帧与帧之间的差别会相当小。相比较P帧的前向预测，B帧的前后双向预测所计算出来的值会更小，所以他的体积比P帧小很多，压缩率也最高。&lt;/p&gt;

&lt;h4&gt;3.4 帧总结&lt;/h4&gt;

&lt;p&gt;　　最后来个总结，I帧是关键帧，是类似于图片形式的存在；P帧是前向预测帧，由前面的帧预测而来；B帧是前后向预测帧，由前一帧和后一帧预测而来。在视频编码中这三种帧都是很重要的，只有把这三种帧合理分配好才能很好的编码视频。如果I帧太多，视频清晰度会相当不错，但体积会比较大；太少也不行，I帧是参考帧，其他两种帧都是间接或直接参考I帧而来的，参考太少的话画面很容易走样，变得模糊。&lt;/p&gt;

&lt;h2&gt;4. 流媒体服务器&lt;/h2&gt;

&lt;p&gt;　　Red5是一个开源项目，用于实现flash与服务器端之间通过rtmp(real time messaging protocal)协议通信，可以实现视频、音频的传输，remote shared object等等。相对于FMS, Red5是免费、开源的。它是一个采用Java开发开源的Flash流媒体服务器。它支持：把音频（MP3）和视频（FLV）转换成播放流； 录制客户端播放流（只支持FLV）；共享对象；现场直播流发布；远程调用。&lt;/p&gt;

&lt;h2&gt;5. 流媒体如何实现拖动和定点播放？&lt;/h2&gt;

&lt;p&gt;　　视频上传到服务器完成后，在服务端需要做文件格式转换，因为客户上传的视频是各种格式的，都需要转换为flv。利用ffmpeg这个开源免费的库可以完成这个步骤，如&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ffmpeg -i [customer.mpeg] -acodec mp3 -ar 22050 -ab 32 -f flv -s 320×240 [result.flv]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;转换后的flv还不能直接用，如果不加入合适的metadata，flv在播放的时候将不能拖动。利用工具给flv文件注入metadata：利用flvtool2这个开源免费的库可以完成这个步骤，如&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;flvtool2 -U [result.flv]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这样，包含duration，frames等信息的metadata将被注入到flv中。对视频中某一帧做截屏来生成缩略图：利用ffmpeg可以完成这个需求，它可以从视频中取出某一帧来保存为图片，如：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ffmpeg -y -i [result.flv] -vframes 1 -ss 00:00:01 -an -vcodec png -f rawvideo -s 320×240 [thumbnailimage.png]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　其中，关于“拖动”，由于整个系统是基于网络的，客户端在拖动之后，必须重新向服务器端发送请求，服务器根据客户端的拖动请求，寻找最接近的拖动点，返回可以播放的数据流，从而完成点播拖动。&lt;br/&gt;
  &lt;img src=&quot;/images/projectImage/flv-server.png&quot; alt=&quot;server&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;5.1 服务器端&lt;/h4&gt;

&lt;p&gt;　　首先，解析flv文件，生成flv视频关键帧列表（这个关键帧列表初始存在于flv文件的metadata中，可以在第一次解析时提取出来保存在外部文件中）表明时间和便宜量的对应关系。然后，当接收到客户端发来的数据请求时，根据客户端拖动的时间点的请求，找出时间距离最近的关键帧，根据偏移量，读取flv的文件数据，然后拼接flv的9字节文件头部（还需要再加上4个字节全零的pre tag size，共13字节），返回。其中关键帧列表可以单独存储在一个外部文件中，通过“视频对象.keyframes.filepositions”属性获取FLV关键帧列表并赋予一个数组，以备拖动定位时调用。&lt;/p&gt;

&lt;h4&gt;5.2 客户端&lt;/h4&gt;

&lt;p&gt;　　客户端需要特别注意的，除了正确的解析视频流并播放，还需要小心时间轴的行进，因为用户拖动的时间位置并不一定是关键帧，所以，需要根据服务器返回的关键帧的真实时间，重新定位播放进度。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
