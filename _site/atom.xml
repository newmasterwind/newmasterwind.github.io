<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>疯子伟哥的世界</title>
   <link href="http://www.itweige.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://www.itweige.com" rel="alternate" type="text/html" />
   <updated>2014-05-22T17:05:50+08:00</updated>
   <id>http://www.itweige.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>如何快速搭建流媒体服务器</title>
     <link href="http://itweige.com/streamMedia-server"/>
     <updated>2014-05-21T00:00:00+08:00</updated>
     <id>http://itweige.com/streamMedia-server</id>
     <content type="html">&lt;p&gt;　　在之前的一文中介绍了关于流媒体及flv的相关知识：&lt;strong&gt;&lt;a href=&quot;http://itweige.com/flv-stream-media/&quot;&gt;流媒体及FLV定点播放浅析&lt;/a&gt;&lt;/strong&gt;，本文将手把手带来如何实现一个基于flv格式视频的流媒体服务器。&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/streamServer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;FLV视频发布方式&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3&gt;HTTP和RTMP方式简介&lt;/h3&gt;

&lt;p&gt;　　现在网络上的视频网站youtube，6rooms和56，发现他们用的播放协议也都是Http(&lt;strong&gt;这个可以用chrome插件或者firebug观察到&lt;/strong&gt;)。按说FMS/Red5作为流媒体服务器，是专门做过优化的。但为何这些网站都没采用RTMP 的协议呢。RTMP 协议和Http比有哪些优势呢，或者说：我们为什么要使用FMS/Red5呢？&lt;br/&gt;
　　两种协议HTTP和RTMP ，有一些不同：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP方式&lt;/strong&gt;：先通过网络将FLV下载到本地缓存（例如youku是默认存放缓存在：C:\Users\xxx用户名\Documents\Youku Files\transcode中，其中的.dat文件就是加密后的视频缓存文件），然后再通过NetConnection的本地连接来播放这个FLV，这种方法是播放本地的视频，并不是播放服务器的视频，因此在本地缓存里可以找到这个FLV。其优点就是服务器下载完这个FLV，服务器就没有消耗了，节省服务器消耗。其缺点就是FLV会缓存在客户端，对FLV的保 密性不好（利用dat格式文件可以有效缓解这种问题）。HTTP的视频协议，主要是在互联网普及之后。在互联网上看视频的需求下形成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RTMP方式&lt;/strong&gt;：通过NetConnection连接到FMS/Red5服务器，并实时播放服务器的FLV文件，这种方式可以任意选择视频播放点（SEEK()），并不象HTTP方式需要缓存完整个FLV文件到本地才可以任意选择播放点。其优点就是FLV不会缓存在客户端，FLV的保密性好，其缺点就是消耗服务器资源，连接始终是实时的。&lt;br/&gt;
　一句话，一个是本地播放，一个是服务器实时播放，因需而定。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HTTP方式变更史&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最初的HTTP视频协议，没有任何特别之处，就是通用的HTTP文件渐进式下载&lt;/strong&gt;。本质就是下载视频文件，而利用视频文件本身的特点，就是存在头部信息，和部分视频帧数据，就完全可以解码播放了。显然这种方式需要将视频文件的头部信息放在文件的前面。有些例如faststart工具，就是专门做这个功能的。但是最为原始的状态下，视频无法进行快进或者跳转播放到文件尚未被下载到的部分。这个时候对HTTP协议提出了range-request的要求。这个目前几乎所有HTTP的服务器都支持了。range-request，是请求文件的部分数据，指定偏移字节数。在视频客户端解析出视频文件的头部后，就可以判断后续视频相应的帧的位置了。或者根据码率等信息，计算相应的为位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持HTTP range-request的服务器&lt;/strong&gt;，目前就可以支持我们一般网络看视频的要求了。但是，这种方式，无法支持实时视频流，或者准实时视频流。因为视频流，是不存在一个视频文件的概念的。HTTP协议播放视频的好处，就是简单。采取通用的HTTP服务器，就可以提供服务，不需要专门类型的服务器，也不需要特别的网络端口，穿过路由器防火墙一点都没有问题。而且还可以利用通用的CDN来简化视频的部署分发的工作，减少带宽的使用。&lt;strong&gt;这个是目前用于PC端或者网页端，视频点播业务，最常见的解决方案&lt;/strong&gt;。客户端的实现，一般采用flash完成，flash本是的videoplayer或者videodisplay控件就可以完成。资源一般采用flv格式，也可以使用mp4格式。在此基础上，多家公司推出了自己的解决方法。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HTTP方式和RTMP方式比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;rtmp从协议实现来讲需要一定的客户端上行流量，而http则小得多，因此在网络环境不佳的条件下其性能不如http；&lt;/li&gt;
&lt;li&gt;rtmp虽然有服务器端开源实现，但是其性能和强度终究不如FMS，例如用于非关键帧seek的Enhanced Seeking和多码流带宽自适应特性等功能由服务器端实现，其协议细节并未公开；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外rtmp方案也无法覆盖iOS/Andriod等移动设备。&lt;/p&gt;

&lt;p&gt;  综合部署成本，复杂度和普适性考虑，对于常规直播点播应用，HTTP方案优于RTMP方案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;开始搭建流媒体服务器&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;　　了解了上述知识背景，下面开始进行服务器的搭建，本服务器的架构将是：&lt;strong&gt;Jwplayer+Red5+Nginx+RTMP&lt;/strong&gt;,其中前端播放器采用了Adobe 开源播放器Jwplayer，流媒体服务器采用Red5，传输协议RTMP。（其实Nginx服务器也是一款不错的选择，其既可以进行流媒体服务，还可以提供负载均衡/反向代理/缓存等多种服务，可惜本文只提供流媒体服务，故采用Red5这款开源服务器。）&lt;br/&gt;
　　利用red5，自动为其目录下的每个flv文件生成filename.meta的xml信息文件（文件第一次播放时自动产生，所以第一次播放会有一些延迟时间用来产生meta文件，是不是可以实现meta文件提前generate呢？比如在文件放入目录后，服务器端有一个进程轮询查询，查询到新的文件进入，提前先产生meta文件），其中包含了flv视频的关键帧，用于seek操作。&lt;/p&gt;

&lt;h3&gt;前端播放器配置&lt;/h3&gt;

&lt;p&gt;jwplayer的用法很简单，自行百度，此处给出一个配置样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var videoStreamer=&#39;rtmp://172.16.90.238:1935/vod/&#39;;//流媒体服务地址
var player = jwplayer(&#39;videoDiv&#39;).setup( {
  width : &quot;100%&quot;,
  height : 280,
  flashplayer : &#39;jwplayer/pl.swf&#39;,
  image : &#39;images/roadPreview.jpg&#39;,
  controlbar : &#39;bottom&#39;,
  file : &quot;red5&quot;,//媒体文件根目录
  provider : &#39;rtmp&#39;,//传输协议
  streamer : videoStreamer//配置服务地址
 });

player.load( [ {
   file : videoUrl//可以通过这种方式更换视频地址，注意不是服务地址
  } ]);
player.play();//开始播放
player.seek(preVideoTime);//根据时间，进行seek地位播放
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Red5服务器配置&lt;/h3&gt;

&lt;p&gt;　　利用red5，自动为其目录下的每个flv文件生成filename.meta的xml信息文件（文件第一次播放时自动产生，所以第一次播放会有一些延迟时间用来产生meta文件，是不是可以实现meta文件提前generate呢？比如在文件放入目录后，服务器端有一个进程轮询查询，查询到新的文件进入，提前先产生meta文件），其中包含了flv视频的关键帧，用于seek操作。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://red5.org/downloads/red5/1_0/&quot;&gt;Red5下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.red5.org/downloads/docs/&quot;&gt;安装说明文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在开启Red5前，需首先查看1935端口是否被占用，Windows下查看当前服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#查看当前系统被占用的端口  
netstat –ano –p tcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果Red5的默认端口1935被占用了，可以为其配置新的端口号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#设置为一个未被其他进程占用的端口，今后流媒体client都通过此端口请求流媒体数据
rtmp.port=1936
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用Red5搭建流媒体服务器时，需要配置其对外提供流媒体的IP（文档位置Red5/conf/ red5.properties）：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#本地通过localhost:port方式访问时，使用此配置。（与下面的配置二选一）
rtmp.host=127.0.0.1
#远程/实际应用场景中通过 IP:port方式访问时，使用此配置。（将下一行#去掉，即生效）
#rtmp.host=10.210.46.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[NOTE]：&lt;strong&gt;如果上述rtmp.host配置的IP地址，与服务器上实际获取的IP不同，则Red5服务无法正常开启。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Red5提供的功能很强大，在提供流媒体服务的同时，还开启了自带的Tomcat，同样需要注意将Tomcat的端口配置为一个未占用的端口。（文档位置Red5/conf/ red5.properties）　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#配置Red5自带的Tomcat服务。
http.port=8888
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Red5流媒体服务器：
直接运行Red5安装路径下的red5.bat文件，当出现如下信息时，表示已经成功启动Red5流媒体服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[INFO] [Launcher:/installer] org.red5.server.service.Installer - Installer service created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Red5提供流媒体服务，即，可以将其上存储的视频数据，以可控的数据流形式，向外提供服务。通常将需要对外提供的原始视频数据，存放于如下位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Red5/webapps/vod/streams/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：本节内容从ningg大神那里学到的，这里只是引用，班门弄斧了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;搭建完成，此时就实现了一个基于RTMP协议和FLV格式视频文件的流媒体服务器搭建。&lt;br/&gt;
上一个我们开发的项目视频播放展示图:&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/stream-server-show.png&quot; alt=&quot;展示图&quot; /&gt;&lt;br/&gt;
更好的优化方案，有待继续深入研究～。～&lt;/p&gt;

&lt;p&gt;最后附RTMP协议详解：
&lt;a href=&quot;http://blog.csdn.net/defonds/article/details/17403225&quot;&gt;实时消息传输协议 RTMP(Real Time Messaging Protocol)&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>初探Nodejs</title>
     <link href="http://itweige.com/Nodejs-rookie"/>
     <updated>2014-05-21T00:00:00+08:00</updated>
     <id>http://itweige.com/Nodejs-rookie</id>
     <content type="html">&lt;p&gt;初探nodejs，占个坑位，这两天浅浅学习下，过两天补上学习内容。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>javascript面向对象编程浅析</title>
     <link href="http://itweige.com/javascript-oop"/>
     <updated>2014-05-20T00:00:00+08:00</updated>
     <id>http://itweige.com/javascript-oop</id>
     <content type="html">&lt;h3&gt;什么是面向对象&lt;/h3&gt;

&lt;p&gt;面向对象最基本的三大特性是继承、封装、多态，javascript不是面向对象的语言，但能实现继承和封装两个特性。&lt;/p&gt;

&lt;h3&gt;弱类型&lt;/h3&gt;

&lt;p&gt;定义变量类型：&lt;/p&gt;

&lt;p&gt;布尔型bool、数值型、字符串类型、函数类型、数组类型、空类型、未定义类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &quot;&quot;; //字符串
var b = []; //数组
var c = function(){} //function函数
var d = {}; //对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面量:&lt;/p&gt;

&lt;p&gt;字面量就类似于我们使用的json数据格式，分为字符串字面量、数组字面量、函数字面量、对象字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cat = {
    //字符串字面量
    name : &quot;cat&quot;,

    //数组字面量
    type : [&quot;波斯猫&quot;, &quot;加菲猫&quot;, &quot;垂耳猫&quot;],

    //函数字面量
    mark : function(){alert(this.name + this.type)},

    //对象字面量
    info : {from : &quot;usa&quot;, &quot;age&quot; : &quot;1&quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建js对象&lt;/h3&gt;

&lt;p&gt;js对象只是一组名称/值对，可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，像词典。&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = new Object();
userObject.lastLoginTime = new Date();
alert(userObject.lastLoginTime); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = {}; // equivalent to new Object()
userObject[&quot;lastLoginTime&quot;] = new Date();
alert(userObject[&quot;lastLoginTime&quot;]);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = { 
    &quot;lastLoginTime&quot; : new Date() 
};
alert(userObject.lastLoginTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建js函数，函数也是对象&lt;/h3&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、普通函数
function func(x) {
    alert(x);
}
func(&quot;blah&quot;);

//2、定义函数，在此创建函数对象，并赋给变量func
var func = function(x) {
    alert(x);
};
func(&quot;blah2&quot;);

//3、用Funciton构造函数，不常用
var func = new Function(&quot;x&quot;, &quot;alert(x);&quot;);
func(&quot;blah3&quot;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用对象初始化器创建对象&lt;/h3&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myConstructor = function(){
}

//添加静态属性
//name属性和alertName()方法作为静态成员添加到了对象实例中
myConstructor.name = &quot;heiniu&quot;;
myConstructor.alertName = function(){
    alert(this.name);
}
//执行,不需要new
myConstructor.alertName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：等价于以下代码，结构更简洁清晰。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//name属性和alertName()方法作为静态成员添加到了对象实例中
var myConstructor = {
    //静态属性
    name : &quot;heiniu&quot;,

    //静态方法
    alertName : function(){
        alert(this.name);
    }
}

//执行,不需要new
myConstructor.alertName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点：简洁明了；&lt;/li&gt;
&lt;li&gt;缺点：创建对象的代码是一次性的&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;使用构造函数创建对象&lt;/h3&gt;

&lt;p&gt;定义构造函数，而不是类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//私有成员就是在构造函数中定义的变量和函数
function myConstructor2(msg, name){

    //公有属性
    this.myMsg = msg;
    this.name = name;

    //私有属性
    var myVersion = &quot;1.0&quot; 

    //私有方法
    function alertMsg(){
        alert(this.myMsg)
        alert(myVersion)
    }
    alertVersion();//实例化时显示信息

    //特权方法，也是公用方法，在构造函数的作用域中使用this关键字定义的方法，尽量不要用，只用于需要访问私有成员的情况。
    this.appendToMsg = fucntion(string){
        this.myMsg += &quot;heiniu_&quot; + string;
        alertMsg();
    }

}

//静态属性和方法，静态成员是直接通过类对象访问的。
myConstructor2.myYear = &quot;2012&quot;;
myConstructor2.now = function(){
    return new Date();
}

//公有方法，修改函数原型，即prototype属性。
//一旦修改原型方法则立即应用到继承的对象和实例中，有风险。
//原型方式会将新方法添加到myConstructor2的底层定义中，而不是myConstructor2实例自身。
myConstructor2.prototype.alertMsg(){
    alert(this.myMsg);
}
myConstructor2.prototype.alertName(){
    alert(this.name);
}

var myObj = new myConstructor2(&quot;hello&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new操作符等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、call()方法,每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。第一个参数用作 this 的对象。其他参数都直接传递给函数自身。
var myObj = {};
myConstructor2.call(myObj,&quot;hello&quot;, &quot;heiniu&quot;)

//2、apply()方法，有两个参数，用作 this 的对象和要传递给函数的参数的数组。
var myObj = {};
myConstructor2.apply(myObj,[&quot;hello&quot;, &quot;heiniu&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;call的工作机制：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someuser = {
    name : &quot;sjm&quot;,
    display : function(words){
        console.log(this.name + &#39; says &#39; + words);
    }
};

var myself = {
    name : &quot;heiniu&quot;
};

someuser.display.call(myself, &#39;fighting!&#39;);
//结果：heiniu says fighting!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;someuser.display是函数的引用，即被调用的函数。&lt;/li&gt;
&lt;li&gt;myself是someuser.display被调用时的上下文对象。&lt;/li&gt;
&lt;li&gt;&#39;fighting!&#39;是传入someuser.display的参数。&lt;/li&gt;
&lt;li&gt;通过call将上下文对象改变为myself对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。&lt;/p&gt;

&lt;p&gt;call和apply的功能一致：以不同的对象作为上下文来调用某个函数，即允许一个对象去调用另一个对象的成员函数。&lt;/p&gt;

&lt;p&gt;call和apply的差别：call以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。&lt;/p&gt;

&lt;p&gt;使用不同的引用来调用同一个函数时，this指针永远是这个引用所属的对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点：可创建出多个规划好的对象，有若干个固定的属性、方法，并能初始化实例化。&lt;/li&gt;
&lt;li&gt;缺点：复杂些，有上下文对象（this指针），即被调用函数所处的环境。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;使用原型和构造函数共同生成对象&lt;/h3&gt;

&lt;p&gt;什么是原型链？&lt;/p&gt;

&lt;p&gt;继承方面,javascript中的每个对象都有一个内部私有的链接指向另一个对象 (或者为 null),这个对象就是原对象的原型. 这个原型也有自己的原型, 直到对象的原型为null为止. 这种一级一级的链结构就称为原型链.&lt;/p&gt;

&lt;p&gt;prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ClassA() {
}

ClassA.prototype.color = &quot;blue&quot;;
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

//继承和扩展
ClassB.prototype = new ClassA();
ClassB.prototype.name = &quot;&quot;;
ClassB.prototype.sayName = function () {
    alert(this.name);
};

//执行
var objA = new ClassA();
var objB = new ClassB();
objA.color = &quot;blue&quot;;
objB.color = &quot;red&quot;;
objB.name = &quot;John&quot;;
objA.sayColor();
objB.sayColor();
objB.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用原型与直接在构造函数内定义的属性 不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构造函数内定义的属性继承方式与原型不同，子对象需要显示调用父对象才能继承构造函数内定义的属性。&lt;/li&gt;
&lt;li&gt;构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。&lt;/li&gt;
&lt;li&gt;构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说是可见的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;原型使用场合：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;除非必须用构造函数闭包，否则尽量用原型定义成员函数，可减少开销&lt;/li&gt;
&lt;li&gt;尽量在构造函数内定义一般成员，尤其是对象或数组，因为用原型定义的成员是多个实例共享的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;原型链机制：&lt;/h3&gt;

&lt;p&gt;javascript分为三类对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、用户创建的对象&lt;/li&gt;
&lt;li&gt;2、构造函数对象&lt;/li&gt;
&lt;li&gt;3、原型对象&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo(){
}
var foo = new Foo();
var obj = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;公有、私有、特权、静态总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;私有和特权成员在函数的内部，他们会被带到函数的每一个实例中生成新的副本，因而将占用大量的内存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;公有的原型成员是对象的一部分，适用于通过new关键字实例化该对象的每一个实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态成员所关联的是类本身，而不同的是大多数方法和属性所关联的是类的实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;私有成员命名规范上用下划线表示，私有成员可避免安全隐患，防止使用者修改某个属性，导致对象内部数据的一致性受到破坏。如&lt;code&gt;_myPrivateProp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&quot;&gt;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&quot;&gt;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>深夜杂念：程序人生</title>
     <link href="http://itweige.com/programmer-thoughts"/>
     <updated>2014-05-17T00:00:00+08:00</updated>
     <id>http://itweige.com/programmer-thoughts</id>
     <content type="html">&lt;h3&gt;夜深人静，思绪静下来，总结一下今天的程序人生见闻和思考，留作日后备注：&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/blogImages/programmer.jpg&quot; alt=&quot;程序员&quot; /&gt;&lt;/p&gt;

&lt;p&gt;记录几点有意义的心得：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所谓专家，就是在一个有限的领域里，把所有的错误都犯过一次。&lt;/li&gt;
&lt;li&gt;和提高技术能力同等重要的是，深入学习、理解自己所在的行业，理解产业链的上下游、公司的运营方式、产品的赢利模式。&lt;/li&gt;
&lt;li&gt;但管努力，莫问前程。&lt;/li&gt;
&lt;li&gt;动手永远高于理念，看100本系统架构书不如自己去亲手搭一遍来的实在。&lt;/li&gt;
&lt;li&gt;还有就是我真的想去 &lt;strong&gt;百度/小米&lt;/strong&gt; 这种公司挑战下自己了,外企的生活对于年轻人就是美丽的“围城”。&lt;/li&gt;
&lt;li&gt;木桶效应：周围木桶板的高度决定了你对木桶存在的价值。&lt;/li&gt;
&lt;li&gt;很多时候，半途而废的背后就是只差一步，要坚持；克服问题，不退缩。&lt;/li&gt;
&lt;li&gt;要有“说做就做”的勇气。&lt;/li&gt;
&lt;li&gt;但如果要开发一些底层的软件，大型的系统的时候，就必须用到C、C++、汇编等开发语言，这是成功尖端人才的一个条件。&lt;/li&gt;
&lt;li&gt;《计算机操作系统》这本书真是个经典。&lt;/li&gt;
&lt;li&gt;日三省乎己：每日睡觉失眠的时候，掏出云笔记反省下今日学到的东西。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身体是革命的本钱。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;
明天买的200多块钱的书要到了，又可以恶补一番了～。～  &lt;br/&gt;
时间不早了，晚安北京。&lt;strong&gt;May 17 2014 1:55 AM&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后推荐一篇博文，关于web系统开发的文章：&lt;br/&gt;
&lt;a href=&quot;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before&quot;&gt;What technical details should a programmer of a web application consider before making the site public?&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>伟哥教你破解--Java线程谜团</title>
     <link href="http://itweige.com/Java-Thread"/>
     <updated>2014-05-15T00:00:00+08:00</updated>
     <id>http://itweige.com/Java-Thread</id>
     <content type="html">&lt;h2&gt;Thread类--关键方法&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Thread类的关键方法有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;yield()&lt;/strong&gt;   ：让出cpu使用权，但是马上进入可执行状态，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sleep(time)&lt;/strong&gt; ：交出cpu使用权，进入限时等待状态，过了time之后重新进入可执行状态。 作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start()&lt;/strong&gt;  ：线程启动，变为可执行状态，也叫就绪状态;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;run()&lt;/strong&gt; ：进入执行状态;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stop()&lt;/strong&gt; :结束，进入死亡状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interrupt()&lt;/strong&gt; ：interrupt对于一个线程，标示着它应该停下它正在做的事情来做些其他的。具体的是由程序员来决定一个线程如何回应interrupt，一般都是让这个线程终止；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;join()&lt;/strong&gt;：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。使用方法：在当前线程A中，有一个B线程的示例线程bt，则在A中执行bt.join()之后，只能等bt执行完才能执行A线程剩下的代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;join(time)&lt;/strong&gt;:跟join()类似，只不过限定了一个时间；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;currentThread()&lt;/strong&gt;:当前正在执行的线程，使用方法如Thread.currentThread().getName()。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Thread状态&lt;/h2&gt;

&lt;p&gt;java中线程主要有5类状态，其中等待/睡眠/阻塞 我在这里归为一类状态，都为等待或者阻塞状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新生状态：刚new出来，还没有run的时候。&lt;/li&gt;
&lt;li&gt;就绪状态：执行了start之后，位于就绪队列中，等待分配cpu执行。&lt;/li&gt;
&lt;li&gt;执行状态：获得到cpu使用权，进入执行状态。&lt;/li&gt;
&lt;li&gt;等待/睡眠/阻塞状态：调用join()/sleep()/wait()或者资源被占用，此时进入阻塞状态。&lt;/li&gt;
&lt;li&gt;死亡状态：就是死了。。。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;线程状态转化图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/projectImage/thread-status.png&quot; alt=&quot;线程状态图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;线程间的关系&lt;/h2&gt;

&lt;p&gt;其实Java中的线程间就存在两大类关系：线程互斥 和 线程同步通信，前者通过synchronized解决，后者通过wait()/notify()/notifyAll()来解决。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程间互斥&lt;/strong&gt;:利用synchronized关键字即可实现，synchronized向jvm申请了一个针对内存对象的锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程间互相唤醒&lt;/strong&gt;: 此时就需要object.wait()和object.notify()了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;其中生产者/消费者模式 就融合了这两种情况，我们一会分析到。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;关于Object类中的wait/notify&lt;/h2&gt;

&lt;p&gt;线程间的同步要用到wait/notify方法，他们在object类中。Java中每个object对象都有一个互斥锁，线程获取到后就形成了互斥操作，wait/notify操作必须在这个互斥的同步区（synchronized块，以object对象为锁）内执行。
object中的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wait()：立即释放对象锁，然后进入等待状态。&lt;/li&gt;
&lt;li&gt;wait(time)：当time时间过去后，就恢复可执行状态了。&lt;/li&gt;
&lt;li&gt;notify()：使得一个waiting状态的线程进入可执行状态。&lt;/li&gt;
&lt;li&gt;notifyAll()：唤醒所以waiting状态的线程。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁的线程进行操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。&lt;/li&gt;
&lt;li&gt;从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。&lt;strong&gt;但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。&lt;/strong&gt;这样就提供了在线程间同步、唤醒的操作。&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;从上面分析来看，wait()和notify()方法都是释放锁，一个是立即释放锁，另一个是等执行完synchronized代码块后在释放锁，同时后者会通知该互斥锁上的一个wait线程进入可执行状态，notifyAll（）的话就是所有该互斥锁上的进程都被唤醒进入可执行状态。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;sleep() wait()的比较&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt; Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制,而sleep则会一直保持它的锁。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;生产者消费者实例&lt;/h2&gt;

&lt;p&gt;生产者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static class Producer implements Runnable { 
        private int start; 
        private int end; 

        Producer(int start, int end) { 
            this.start = start; 
            this.end = end; 
        } 

        @Override 
        public void run() { 
            for (int i = start; i &amp;lt; end; i ++) { 
                synchronized (basket) { 
                    try { 
                        while (basket.size() == capacity) { 
                            basket.wait(); 
                        } 
                        String p = &quot; PRO&quot; + i; 
                        System.out.println(Thread.currentThread().getName() + p); 
                        basket.add(p); 
                        basket.notifyAll(); 
                        Thread.yield(); // 让出当前线程的执行权,有利于看出交替线程运行的效果 
                    } catch (InterruptedException e) { 
                        e.printStackTrace(); 
                        break; 
                    } 
                } 
            } 
        } 
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消费者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; static class Customer implements Runnable { 
        @Override 
        public void run() { 
            while (true) { 
                synchronized (basket) { 
                    try{ 
                        while (basket.size() == 0) { 
                            basket.wait(); 
                        } 
                        System.out.println(Thread.currentThread().getName() + basket.remove(0)); 
                        basket.notifyAll(); 
                    } catch (InterruptedException e) { 
                        System.out.println(Thread.currentThread().getName() + &quot;退出&quot;); 
                        break; 
                    } 
                } 
            } 
        } 
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各位客官注意看wait和notifyAll的用法。&lt;/p&gt;

&lt;h2&gt;线程池&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3&gt;为什么要用线程池:&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。&lt;br/&gt;
2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Java线程池类介绍&lt;/h3&gt;

&lt;p&gt;Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。下面这张图完整描述了线程池的类体系结构：&lt;br/&gt;
&lt;img src=&quot;/images/projectImage/java-threadPool.png&quot; alt=&quot;线程池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java线程池中几个比较重要的类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ExecutorService： 真正的线程池接口。&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService: 和Timer/TimerTask类似，解决那些需要任务重复执行的问题。&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor : ExecutorService的默认实现。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;线程池类为 java.util.concurrent.ThreadPoolExecutor，常用构造方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,RejectedExecutionHandler handler) 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;corePoolSize： 线程池维护线程的最少数量&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池维护线程的最大数量&lt;/li&gt;
&lt;li&gt;keepAliveTime： 线程池维护线程所允许的空闲时间&lt;/li&gt;
&lt;li&gt;unit： 线程池维护线程所允许的空闲时间的单位&lt;/li&gt;
&lt;li&gt;workQueue： 线程池所使用的缓冲队列&lt;/li&gt;
&lt;li&gt;handler： 线程池对拒绝任务的处理策略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当一个任务通过execute(Runnable)方法欲添加到线程池时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行）&lt;/li&gt;
&lt;li&gt;如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void execute(Runnable command) {
      if (command == null)
          throw new NullPointerException();
      /*
       * Proceed in 3 steps:
       *
       * 1. If fewer than corePoolSize threads are running, try to
       * start a new thread with the given command as its first
       * task. The call to addWorker atomically checks runState and
       * workerCount, and so prevents false alarms that would add
       * threads when it shouldn&#39;t, by returning false.
       *
       * 2. If a task can be successfully queued, then we still need
       * to double-check whether we should have added a thread
       * (because existing ones died since last checking) or that
       * the pool shut down since entry into this method. So we
       * recheck state and if necessary roll back the enqueuing if
       * stopped, or start a new thread if there are none.
       *
       * 3. If we cannot queue task, then we try to add a new
       * thread. If it fails, we know we are shut down or saturated
       * and so reject the task.
       */
      int c = ctl.get();
      if (workerCountOf(c) &amp;lt; corePoolSize) {
          if (addWorker(command, true))
              return;
          c = ctl.get();
      }
      if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
          int recheck = ctl.get();
          if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
              reject(command);
          else if (workerCountOf(recheck) == 0)
              addWorker(null, false);
      }
      else if (!addWorker(command, false))
          reject(command);
  }  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;分析可得：当新任务到来时，线程池处理优先级：corePollSize&gt;任务队列&gt;maximumPoolSize。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;现成的Java线程池工厂&lt;/h3&gt;

&lt;p&gt;配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在&lt;strong&gt;Executors&lt;/strong&gt;类（上图中，图片右下角这个类）里面提供了一些静态工厂，生成一些常用的线程池：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;newSingleThreadExecutor&lt;/strong&gt;：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newFixedThreadPool&lt;/strong&gt;：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newCachedThreadPool&lt;/strong&gt;：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newScheduledThreadPool&lt;/strong&gt;：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;因为这些方法在Executors类中都是静态方法，所以可以直接通过如下的方法获得到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor threadPool=Executors.newCachedThreadPool();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这差不多就是Java线程里面的全部内容了，大概有个全方位的了解，用于以后的精学，建议配合Jdk源码进行更深入的学习。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>流媒体及FLV定点播放浅析</title>
     <link href="http://itweige.com/flv-stream-media"/>
     <updated>2014-05-13T00:00:00+08:00</updated>
     <id>http://itweige.com/flv-stream-media</id>
     <content type="html">&lt;h2&gt;1. 何谓流媒体&lt;/h2&gt;

&lt;h4&gt;1.1 流媒体概述&lt;/h4&gt;

&lt;p&gt;　　所谓流媒体是指采用流式传输的方式在Internet播放的媒体格式。 流媒体又叫流式媒体，它是指商家用一个视频传送服务器把节目当成数据包发出，传送到网络上。用户通过解压设备对这些数据进行解压后，节目就会像发送前那样显示出来。&lt;br/&gt;
　　流媒体是指以流的方式在网络中传输音频、视频和多媒体文件的形式。 流媒体文件格式是支持采用流式传输及播放的媒体格式。流式传输方式是将视频和音频等多媒体文件经过特殊的压缩方式分成一个个压缩包，由服务器向用户计算机连续、实时传送。在采用流式传输方式的系统中，用户不必像非流式播放那样等到整个文件全部下载完毕后才能看到当中的内容，而是只需要经过几秒钟或几十秒的启动延时即可在用户计算机上利用相应的播放器对压缩的视频或音频等流式媒体文件进行播放，剩余的部分将继续进行下载，直至播放完毕。&lt;br/&gt;
　　流式媒体在播放前并不下载整个文件，只将开始部分内容存入内存，流式媒体的数据流随时传送随时播放，只是在开始时有一些延迟。流媒体实现的关键技术就是流式传输。流式传输定义很广泛，现在主要指通过网络传送媒体（如视频、音频）的技术总称。其特定含义为通过Internet 将影视节目传送到PC机。实现流式传输有两种方法：实时流式传输（Real time streaming）和顺序流式传输（progressive streaming）。一般说来，如视频为实时广播，或使用流式传输媒体服务器，或应用如RTSP的实时协议，即为实时流式传输。如使用HTTP服务器，文件即通过顺序流发送。&lt;/p&gt;

&lt;h4&gt;1.2 流媒体技术&lt;/h4&gt;

&lt;blockquote&gt;&lt;p&gt;所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;1.3 流媒体传输方式&lt;/h5&gt;

&lt;p&gt;　　流媒体传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。&lt;strong&gt;顺序流式传输与实时流式传输的区别&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顺序流式传输是顺序下载，在下载文件的同时用户可观看在线媒体，在给定时刻，用户只能观看已下载的那部分，而不能跳到还未下载的前头部分，顺序流式传输不象实时流式传输在传输期间根据用户连接的速度做调整。由于标准的HTTP服务器可发送这种形式的文件，也不需要其他特殊协议，它经常被称作HTTP流式传输。顺序流式传输比较适合高质量的短片段，如片头、片尾和广告，由于该文件在播放前观看的部分是无损下载的，这种方法保证电影播放的最终质量。这意味着用户在观看前，必须经历延迟，对较慢的连接尤其如此。对通过调制解调器发布短片段，顺序流式传输显得很实用，它允许用比调制解调器更高的数据速率创建视频片段。尽管有延迟，毕竟可让你发布较高质量的视频片段。顺序流式文件是放在标准HTTP或FTP服务器上，易于管理，基本上与防火墙无关。顺序流式传输不适合长片段和有随机访问要求的视频，如：讲座、演说与演示。它也不支持现场广播，严格说来，它是一种点播技术。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时流式传输指保证媒体信号带宽与网络连接配匹，使媒体可被实时观看到。实时流与HTTP流式传输不同，他需要专用的流媒体服务器与传输协议。实时流式传输总是实时传送，特别适合现场事件，也支持随机访问，用户可快进或后退以观看前面或后面的内容。理论上，实时流一经播放就可不停止，但实际上，可能发生周期暂停。实时流式传输必须配匹连接带宽，这意味着在以调制解调器速度连接时图象质量较差。而且，由于出错丢失的信息被忽略掉，网络拥挤或出现问题时，视频质量很差。如欲保证视频质量，顺序流式传输也许更好。实时流式传输需要特定服务器，如：QuickTime Streaming Server、RealServer与Windows Media Server。这些服务器允许你对媒体发送进行更多级别的控制，因而系统设置、管理比标准HTTP服务器更复杂。实时流式传输还需要特殊网络协议，如：RTSP (Realtime Streaming Protocol)或MMS (Microsoft Media Server)。这些协议在有防火墙时有时会出现问题，导致用户不能看到一些地点的实时内容。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1.4 流媒体传输协议&lt;/h4&gt;

&lt;p&gt;　　流媒体的传输需要合适的传输协议，在internet上的文件传输大部分都是建立在tcp协议的基础上，也有一些是以ftp传输协议的方式进行传输，但采用这些传输协议都不能实现实时方式的传输。随着流媒体技术的深入研究，比较成熟的流媒体传输一般都是采用建立在udp协议上的rtp/rtsp实时传输协议。对于对传输质量要求不是很高，而对传输速度则有很高的要求的视音频流媒体文件来说，采用udp协议则更合适．下面，让我们来看一下现在使用的主要的流媒体协议：&lt;br/&gt;
　　1. RTSP（Real Time Streaming Protocol），实时流媒体协议，它是由RealNetworks和Netscape共同提出的，现在用于RealNetworks的Real Media产品中；&lt;br/&gt;
　　2. PNM（Progressive Networks Audio），这也是Real专用的实时传输协议，它一般采用UDP协议，并占用7070端口，但当你的服务器在防火墙内且7070端口被挡，且你的服务器把SmartingNetwork设为真时，则采用http协议，并占用默认的80端口；&lt;br/&gt;
　　3. MMS（Microsoft Media Server protocol），这是微软的流媒体服务器协议，MMS 是连接 Windows Media 单播服务的默认方法。&lt;/p&gt;

&lt;h4&gt;1.5 流媒体包重组排序&lt;/h4&gt;

&lt;p&gt;　　因为internet是以包为单位进行异步传输的，因此多媒体数据在传输中要被分解成许多包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包的现象．为此，必须采用缓存技术来纠正由于数据到达次序发生改变而产生的混乱状况，利用缓存对到达的数据包进行正确排序，从而使视音频数据能连续正确地播放．缓存中存储的是某一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的．流媒体在播放时不断读取缓存中的数据进行播放，播放完后该数据便被立即清除，新的数据将存入到缓存中．因此，在播放流媒体文件时并不需占用太大的缓存空间．&lt;/p&gt;

&lt;h2&gt;2. 详解FLV格式&lt;/h2&gt;

&lt;p&gt;　　FLV 是FLASH VIDEO的简称，FLV流媒体格式是随着Flash MX的推出发展而来的视频格式。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能.当前主流的媒体网站像国内的优酷、国外youtube其标清格式的文件均采用flv的格式。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。&lt;br/&gt;
　　FLV是一个二进制文件，其文件格式如下图 ，由文件头（FLV header）和很多tag组成。tag又可以分成三类：audio,video,script，分别代表音频流，视频流，脚本流（关键字或者文件信息之类）。&lt;br/&gt;
  　　参考链接：  http://wuyuans.com/2012/08/flv-format/&lt;/p&gt;

&lt;h4&gt;2.1 FLV Header&lt;/h4&gt;

&lt;p&gt;　　FLV的Header信息一般比较简单，记录了flv的类型、版本等信息，是flv的开头，一般占9bytes。。如下图中解析：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;/images/projectImage/flv-flvHeader.jpeg&quot; alt=&quot;flv header &quot; /&gt;&lt;br/&gt;
　　文件类型：3bytes 总是FLV（0x46 0x4C 0x56），否则就不是在ffmpeg中在没有指定文件格式的情况下，也是通过这个字段来探测文件是否属于FLV格式的。&lt;br/&gt;
　　版本：1byte 一般是0x01，表示FLV version 1&lt;br/&gt;
　　流信息：1byte 倒数第一bit是1表示有视频，倒数第三bit是1表示有音频，其他都应该是0（有些软件如flvtool2可能造成倒数第四bit是1，不过也没发现有什么不对）&lt;br/&gt;
　　header长度：4bytes 整个文件头的长度，一般是9（3+1+1+4），当然头部字段也有可能包含其它信息这个时间其长度就不是9了。&lt;/p&gt;

&lt;h4&gt;2.2 FLV Body&lt;/h4&gt;

&lt;p&gt;　　body部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间PreViousTagSize，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图：&lt;br/&gt;
   &lt;img src=&quot;/images/projectImage/flv-flvBody.jpeg&quot; alt=&quot;flv header &quot; /&gt;&lt;/p&gt;

&lt;h5&gt;2.2.1 Tag&lt;/h5&gt;

&lt;p&gt;　　每个Tag也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息.&lt;/p&gt;

&lt;h6&gt;2.2.2 Tag Data&lt;/h6&gt;

&lt;p&gt;　　数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。&lt;/p&gt;

&lt;h4&gt;2.3 FLV视频发布方式&lt;/h4&gt;

&lt;p&gt;　　&lt;strong&gt;FLV视频有两种发布方式:HTTP方式和TRMP流媒体方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;2.3.1  HTTP方式&lt;/h5&gt;

&lt;p&gt;　　这种方式要下载FLV视频文件到本地播放，一旦FLV视频文件下载完成，就不会消耗服务器的资源和带宽，但是拖动功能没有RTMP/RTMP流媒体方式强大。&lt;/p&gt;

&lt;h5&gt;2.3.2  RTMP/RTMP流媒体方式&lt;/h5&gt;

&lt;p&gt;　　这种方式不用下载FLV视频文件到本地，可以实时的播放flv文件，可以任意拖拽播放进度条，但是比较消耗服务器的资源，&lt;/p&gt;

&lt;h2&gt;3.关于视频帧&lt;/h2&gt;

&lt;p&gt;　　我们都知道视频是由图片构成的，就像早期的胶片电影一样，一幅幅图片连续播放就形成了视频，在视频中我们管这些图片叫帧。在x264中有三种基本的帧类型：I帧、P帧和B帧.&lt;br/&gt;
　　参考链接：http://blog.163.com/yan_ku@126/blog/static/122375126201210199813425/&lt;/p&gt;

&lt;h4&gt;3.1 I帧&lt;/h4&gt;

&lt;p&gt;　　I帧(I frame)，又称为内部画面(intra picture)，I帧通常是每个GOP(MPEG 所使用的一种视频压缩技术)的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。在MPEG编码的过程中，部分视频帧序列压缩成为I帧；部分压缩成P帧；还有部分压缩成B帧。I帧法是帧内压缩法，也称为“关键帧”压缩法。————百度百科&lt;br/&gt;
　　也就是说I帧其实是图片编码的，类似于JPEG编码，可以理解为电影中的胶片。而且I帧的生成是没有参考前后帧的，他只是作为参考点而存在，其他类型的帧都是以他为原型经过适当编码而来的。&lt;/p&gt;

&lt;h4&gt;3.2 P帧&lt;/h4&gt;

&lt;p&gt;　　前向预测编码帧 又称predictive-frame，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。&lt;br/&gt;
　　P帧是由前面的帧预测而来的，打个比方，I帧就是父母，P帧相当于孩子，孩子还可以再生孩子，一切的起源肯定是父母，也就是I帧。&lt;br/&gt;
  &lt;img src=&quot;/images/projectImage/flv-PFrame.png&quot; alt=&quot;B Frame&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;3.3 B帧&lt;/h4&gt;

&lt;p&gt;　　双向预测内插编码帧 又称bi-directional interpolated prediction frame 。B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。&lt;br/&gt;
　　一般视频的帧率为23，有的甚至到了30，也就是说一秒钟有23帧的画面，除非那部电影的场面相当动作，不然帧与帧之间的差别会相当小。相比较P帧的前向预测，B帧的前后双向预测所计算出来的值会更小，所以他的体积比P帧小很多，压缩率也最高。&lt;/p&gt;

&lt;h4&gt;3.4 帧总结&lt;/h4&gt;

&lt;p&gt;　　最后来个总结，I帧是关键帧，是类似于图片形式的存在；P帧是前向预测帧，由前面的帧预测而来；B帧是前后向预测帧，由前一帧和后一帧预测而来。在视频编码中这三种帧都是很重要的，只有把这三种帧合理分配好才能很好的编码视频。如果I帧太多，视频清晰度会相当不错，但体积会比较大；太少也不行，I帧是参考帧，其他两种帧都是间接或直接参考I帧而来的，参考太少的话画面很容易走样，变得模糊。&lt;/p&gt;

&lt;h2&gt;4. 流媒体服务器&lt;/h2&gt;

&lt;p&gt;　　Red5是一个开源项目，用于实现flash与服务器端之间通过rtmp(real time messaging protocal)协议通信，可以实现视频、音频的传输，remote shared object等等。相对于FMS, Red5是免费、开源的。它是一个采用Java开发开源的Flash流媒体服务器。它支持：把音频（MP3）和视频（FLV）转换成播放流； 录制客户端播放流（只支持FLV）；共享对象；现场直播流发布；远程调用。&lt;/p&gt;

&lt;h2&gt;5. 流媒体如何实现拖动和定点播放？&lt;/h2&gt;

&lt;p&gt;　　视频上传到服务器完成后，在服务端需要做文件格式转换，因为客户上传的视频是各种格式的，都需要转换为flv。利用ffmpeg这个开源免费的库可以完成这个步骤，如&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ffmpeg -i [customer.mpeg] -acodec mp3 -ar 22050 -ab 32 -f flv -s 320×240 [result.flv]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;转换后的flv还不能直接用，如果不加入合适的metadata，flv在播放的时候将不能拖动。利用工具给flv文件注入metadata：利用flvtool2这个开源免费的库可以完成这个步骤，如&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;flvtool2 -U [result.flv]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这样，包含duration，frames等信息的metadata将被注入到flv中。对视频中某一帧做截屏来生成缩略图：利用ffmpeg可以完成这个需求，它可以从视频中取出某一帧来保存为图片，如：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ffmpeg -y -i [result.flv] -vframes 1 -ss 00:00:01 -an -vcodec png -f rawvideo -s 320×240 [thumbnailimage.png]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　其中，关于“拖动”，由于整个系统是基于网络的，客户端在拖动之后，必须重新向服务器端发送请求，服务器根据客户端的拖动请求，寻找最接近的拖动点，返回可以播放的数据流，从而完成点播拖动。&lt;br/&gt;
  &lt;img src=&quot;/images/projectImage/flv-server.png&quot; alt=&quot;server&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;5.1 服务器端&lt;/h4&gt;

&lt;p&gt;　　首先，解析flv文件，生成flv视频关键帧列表（这个关键帧列表初始存在于flv文件的metadata中，可以在第一次解析时提取出来保存在外部文件中）表明时间和便宜量的对应关系。然后，当接收到客户端发来的数据请求时，根据客户端拖动的时间点的请求，找出时间距离最近的关键帧，根据偏移量，读取flv的文件数据，然后拼接flv的9字节文件头部（还需要再加上4个字节全零的pre tag size，共13字节），返回。其中关键帧列表可以单独存储在一个外部文件中，通过“视频对象.keyframes.filepositions”属性获取FLV关键帧列表并赋予一个数组，以备拖动定位时调用。&lt;/p&gt;

&lt;h4&gt;5.2 客户端&lt;/h4&gt;

&lt;p&gt;　　客户端需要特别注意的，除了正确的解析视频流并播放，还需要小心时间轴的行进，因为用户拖动的时间位置并不一定是关键帧，所以，需要根据服务器返回的关键帧的真实时间，重新定位播放进度。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>服务器Push技术--总结</title>
     <link href="http://itweige.com/ServerPush"/>
     <updated>2014-05-12T00:00:00+08:00</updated>
     <id>http://itweige.com/ServerPush</id>
     <content type="html">&lt;h1&gt;1.网络上的讨论：&lt;/h1&gt;

&lt;h2&gt;1.1 浏览器端：&lt;/h2&gt;

&lt;h3&gt;1.1.1.轮询：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;浏览器做不到开端口监听，所以一般是轮询。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.2.用firebug调试一下weibo.com的网络请求可以发现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;微博用的是轮询来实现消息提醒的，应该是用set timer隔个30秒或一分钟去服务器进行查询。和即时通信的web应用不同，微博提醒实时性要求不高，所以用轮询方式比较合理，没有必要用长连接。没错，不是非要使用长连接的。长连接对象保存在服务器，要占用一定的内存。降低了服务器的并发。除非实时性要求非常高的应用。例如WEB IM，否则不需要长连接。
开新浪微薄其实你就会发现，其实他们是会定时去请求  
http://rm.api.weibo.com/remind/unread_count.json  
这个地址的，大概每隔30秒左右一次，如下是我打开微薄后的请求地址：  
http://rm.api.weibo.com/remind/unread_count.json?source=3818214747&amp;amp;target=api&amp;amp;user_id=1700602585&amp;amp;_pid=10001&amp;amp;count=1&amp;amp;callback=STK_132196097145395  
在服务器端，他们应该是把用户的通知放到了缓存里，用户请求时，只要返回对应的通知信息就行，只要有负载均衡的服务器，压力应该不成问题，另外这些通知的维护，就像@范铭川说的那样，会一系列的策略以及程序去维护。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.3.gtalk和facebook用的是comet：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;http://www.ibm.com/developerworks/cn/web/wa-lo-comet/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.4.使用 HTML5 WebSocket 构建实时 Web 应用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;不过要求服务器端要起一个socket端口，使用wsc:// 协议连接。这种是比较即时的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.5.服务器端与浏览器端保持长连接实现推送的实现：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;一种机制是由网景于1995年引入，基于一种特定的名叫“multipart/x-mixed-replace”的MIME类型[1]：http://www.cnblogs.com/syhan/archive/2006/12/31/609281.html  
第二种方式： Web服务器通过CGI提供这种功能（如Apache上不处理请求头的脚本）。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.6.基于 Java 的成熟的服务器推送框架有 DWR  / Pushlet。&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;**DW**是一个开放源码的使用 Apache许可协议的解决方案，它包含服务器端 Java库、一个 DWR servlet以及 JavaScript库。虽然 DWR不是 Java平台上唯一可用的 Ajax-RPC 工具包，但是它是最成熟的，而且提供了许多有用的功能。DW[1]R 从 2.0 开始增加了 push 功能 , 也就是在异步传输的情况下可以从 Web-Server 端发送数据到 Browser。

**Pushlet** 是一个开源的 Comet 框架，在设计上有很多值得借鉴的地方，对于开发轻量级的 Comet 应用很有参考价值。
观察者模型
Pushlet 使用了观察者模型：客户端发送请求，订阅感兴趣的事件；服务器端为每个客户端分配一个会话 ID 作为标记，事件源会把新产生的事件以多播的方式发送到订阅者的事件队列里。
客户端 JavaScript 库
pushlet 提供了基于 AJAX 的 JavaScript 库文件用于实现长轮询方式的“服务器推”；还提供了基于 iframe 的 JavaScript 库文件用于实现流方式的“服务器推”。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.2 客户端：&lt;/h2&gt;

&lt;h3&gt;1.2.1 普通请求&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;常用的方法有2种。一种是定时去服务器上查询数据，也叫Polling，还有一种手机跟服务器之间维护一个 TCP 长连接，当服务器有数据时，实时推送到客户端，也就是我们说的 Push。从耗费的电量、流量和数据送达的及时性来说，Push 都会有明显的优势，但 Push 的实现和维护成本相对较高。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.2.2 push服务商提供服务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如：OpenMarket’s Push Notifications Service 
It lets you send messages to people who have installed your application on Apple, Android, and BlackBerry devices：
http://www.openmarket.com/messaging/push-notifications/  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1&gt;2.浏览器端总结：&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;2.1 推方式介绍&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;其中最常用的就是轮询 (Polling) 和 Comet 技术，而 Comet 技术实际上是轮询技术的改进，又可细分为两种实现方式，一种是长轮询机制，一种称为流技术。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;轮询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的最大问题是，当客户端以固定频率向服务器发起请求的时候，服务器端的数据可能并没有更新，这样会带来很多无谓的网络传输，所以这是一种非常低效的实时方案。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 长轮询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    长轮询是对定时轮询的改进和提高，目地是为了降低无效的网络传输。当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。当然，如果服务端的数据变更非常频繁的话，这种机制和定时轮询比较起来没有本质上的性能的提高。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 流：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    流技术方案通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制在用户体验上有一点问题，需要针对不同的浏览器设计不同的方案来改进用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;综合这几种方案，您会发现这些目前我们所使用的所谓的实时技术并不是真正的实时技术，它们只是在用 Ajax
方式来模拟实时的效果，在每次客户端和服务器端交互的时候都是一次 HTTP 的请求和应答的过程，而每一次的 HTTP 请求和应答都带有完整的HTTP头信息，这就增加了每次传输的数据量，而且这些方案中客户端和服务器端的编程实现都比较复杂，在实际的应用中，为了模拟比较真实的实时效果，开发人员往往需要构造两个
HTTP连接来模拟客户端和服务器之间的双向通讯，一个连接用来处理客户端到服务器端的数据传输，一个连接用来处理服务器端到客户端的数据传输，这不可避免地增加了编程实现的复杂度，也增加了服务器端的负载，制约了应用系统的扩展性。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;2.2 Comet&lt;/h2&gt;

&lt;h3&gt;2.2.1 comet介绍：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    参考链接：http://blog.csdn.net/ocean20/article/details/3420693
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;comet定义&lt;/strong&gt;：简单说还是利用Ajax与服务器建立http长连接查询是否有数据更新，服务器收到一个连接如果没有数据更新就阻塞这个连接不要返回给客户端，直到有新数据再返回给客户端。Web客户端，发起的连接一旦被返回，或者超时就再次建立http长连接。这样就能保证数据的即时更新，以及尽量减少服务器的计算工作。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;下面将介绍两种 Comet 应用的实现模型。&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;基于 AJAX 的长轮询（long-polling）方式&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新。使用 AJAX 实现“服务器推”与传统的 AJAX 应用不同之处在于：
    1. 服务器端会阻塞请求直到有数据传递或超时才返回。
    2. 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。
    3. 当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;iframe流&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。iframe流方式的优点是浏览器兼容好，Google公司在一些产品中使用了iframe流，如Google Talk。iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。&lt;/p&gt;

&lt;p&gt;在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如“&lt;script type=&quot;text/javascript&quot;&gt;js_func(“data from server ”)&lt;/script&gt;”。服务器端将返回的数据作为客户端 JavaScript 函数的参数传递；客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码。&lt;/p&gt;

&lt;p&gt;每次数据传送不会关闭连接，连接只会在通信出现错误时，或是连接重建时关闭（一些防火墙常被设置为丢弃过长的连接， 服务器端可以设置一个超时时间， 超时后通知客户端重新建立连接，并关闭原来的连接）。&lt;/p&gt;

&lt;p&gt;使用 iframe 请求一个长连接有一个很明显的不足之处：IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成，而且 IE 上方的图标会不停的转动，表示加载正在进行。Google 的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。Alex Russell 在 “What else is burried down in the depth&#39;s of Google&#39;s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的 comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持 IE、Mozilla Firefox 浏览器，可以作为参考。&lt;/p&gt;

&lt;h2&gt;2.3 如何有效的释放和利用资源：在客户和服务器之间保持“心跳”信息&lt;/h2&gt;

&lt;p&gt;在浏览器与服务器之间维持一个长连接会为通信带来一些不确定性：因为数据传输是随机的，客户端不知道何时服务器才有数据传送。服务器端需要确保当客户端不再工作时，释放为这个客户端分配的资源，防止内存泄漏。因此需要一种机制使双方知道大家都在正常运行。在实现上：
服务器端在阻塞读时会设置一个时限，超时后阻塞读调用会返回，同时发给客户端没有新数据到达的心跳信息。此时如果客户端已经关闭，服务器往通道写数据会出现异常，服务器端就会及时释放为这个客户端分配的资源。
如果客户端使用的是基于 AJAX 的长轮询方式；服务器端返回数据、关闭连接后，经过某个时限没有收到客户端的再次请求，会认为客户端不能正常工作，会释放为这个客户端分配、维护的资源。
当服务器处理信息出现异常情况，需要发送错误信息通知客户端，同时释放资源、关闭连接。&lt;/p&gt;

&lt;h2&gt;2.4 comet应用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    目前Comet主要应用在一些股票web客户端，以及一些基于web的即时聊天系统中。比较成熟的框架有Dojo ，Dwr 等一些Ajax框架中实现了该功能。 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Comet  优、 缺点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br/&gt;
长期占用连接，丧失了无状态高并发的特点。
server push不会是一个没有副作用的解决方案，是否适合还要仔细权衡。
&lt;strong&gt;优点&lt;/strong&gt;&lt;br/&gt;
实时性好（消息延时小）
性能好（能支持大量用户）&lt;/p&gt;

&lt;h2&gt;2.5 Pushlet - 开源 Comet 框架&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;Pushlet 是一个开源的 Comet 框架，在设计上有很多值得借鉴的地方，对于开发轻量级的 Comet 应用很有参考价值。 观察者模型
Pushlet 使用了观察者模型：客户端发送请求，订阅感兴趣的事件；服务器端为每个客户端分配一个会话 ID
作为标记，事件源会把新产生的事件以多播的方式发送到订阅者的事件队列里。 客户端 JavaScript 库 pushlet 提供了基于
AJAX 的 JavaScript 库文件用于实现长轮询方式的“服务器推”；还提供了基于 iframe 的 JavaScript
库文件用于实现流方式的“服务器推”。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;JavaScript 库做了很多封装工作：
    1. 定义客户端的通信状态：STATE_ERROR、STATE_ABORT、STATE_NULL、STATE_READY、STATE_JOINED、STATE_LISTENING；
    2. 保存服务器分配的会话 ID，在建立连接之后的每次请求中会附上会话 ID 表明身份；
    3. 提供了 join()、leave()、subscribe()、 unsubsribe()、listen() 等 API 供页面调用；
    4. 提供了处理响应的 JavaScript 函数接口 onData()、onEvent()…
网页可以很方便地使用这两个 JavaScript 库文件封装的 API 与服务器进行通信。
客户端与服务器端通信信息格式
pushlet 定义了一套客户与服务器通信的信息格式，使用 XML 格式。定义了客户端发送请求的类型：join、leave、subscribe、unsubscribe、listen、refresh；以及响应的事件类型：data、join_ack、listen_ack、refresh、heartbeat、error、abort、subscribe_ack、unsubscribe_ack。
服务器端事件队列管理
pushlet 在服务器端使用 Java Servlet 实现，其数据结构的设计框架仍可适用于 PHP、C 编写的后台客户端。
Pushlet 支持客户端自己选择使用流、拉（长轮询）、轮询方式。服务器端根据客户选择的方式在读取事件队列（fetchEvents）时进行不同的处理。“轮询”模式下 fetchEvents() 会马上返回。”流“和”拉“模式使用阻塞的方式读事件，如果超时，会发给客户端发送一个没有新信息收到的“heartbeat“事件，如果是“拉”模式，会把“heartbeat”与“refresh”事件一起传给客户端，通知客户端重新发出请求、建立连接。
客户服务器之间的会话管理
服务端在客户端发送 join 请求时，会为客户端分配一个会话 ID， 并传给客户端，然后客户端就通过此会话 ID 标明身份发出subscribe 和 listen 请求。服务器端会为每个会话维护一个订阅的主题集合、事件队列。
服务器端的事件源会把新产生的事件以多播的方式发送到每个会话（即订阅者）的事件队列里。&lt;/p&gt;

&lt;h2&gt;2.6 其他服务器推技术&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;Comet 只是众多服务器推技术中的一种，目前市面上还有许多其他流行服务器推技术。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;2.6.1.WebSocket（最新的技术）&lt;/h3&gt;

&lt;p&gt;websocket参考：
http://www.ibm.com/developerworks/cn/web/1112_huangxa_websocket/
http://www.websocket.org/index.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    在HTML5标准中，定义了客户端和服务器通讯的WebSocket方式，在得到浏览器支持以后，WebSocket将会取代Comet成为服务器推送的方法，目前chrome、Firefox、Opera、Safari等主流版本均支持，Internet Explorer从10开始支持。不过要求服务器端要起一个socket端口，使用wsc:// 协议连接。这种是比较即时的。
    有“Web 的 TCP ”之称的 WebSocket 格外吸引开发人员的注意。WebSocket 的出现使得浏览器提供对 Socket 的支持成为可能，从而在浏览器和服务器之间提供了一个基于 TCP 连接的双向通道。
    HTML5 WebSocket 设计出来的目的就是要取代轮询和 Comet 技术，使客户端浏览器具备像 C/S 架构下桌面系统的实时通讯能力。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和轮询以及 Comet 技术比较，具有很大的性能优势。
    WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个典型的 WebSocket 发起请求和得到响应的例子看起来如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;清单 1. WebSocket 握手协议

客户端到服务端： 
GET /demo HTTP/1.1 
Host: example.com 
Connection: Upgrade 
Sec-WebSocket-Key2: 12998 5 Y3 1 .P00 
Upgrade: WebSocket 
Sec-WebSocket-Key1: 4@1 46546xW%0l 1 5 
Origin: http://example.com 
[8-byte security key] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端到客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 101 WebSocket Protocol Handshake 
Upgrade: WebSocket 
Connection: Upgrade 
WebSocket-Origin: http://example.com 
WebSocket-Location: ws://example.com/demo 
[16-byte hash response]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.6.1.2.Flash XMLSocket&lt;/h3&gt;

&lt;p&gt;这种方案实现的基础是：&lt;/p&gt;

&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;Flash 提供了 XMLSocket 类。&lt;/li&gt;
&lt;li&gt;JavaScript 和 Flash 的紧密结合：在 JavaScript 可以直接调用 Flash 程序提供的接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;但此方案的缺点在于：&lt;/p&gt;

&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;因为 XMLSocket 没有 HTTP 隧道功能，XMLSocket 类不能自动穿过防火墙；&lt;/li&gt;
&lt;li&gt;因为是使用套接口，需要设置一个通信端口，防火墙、代理服务器也可能对非 HTTP 通道端口进行限制； 不过这种方案在一些网络聊天室，网络互动游戏中已得到广泛使 用 。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3&gt;2.6.1.3.Java Applet 套接口&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;在客户端使用 Java Applet，通过  java.net.Socket  或  java.net.DatagramSocket  或
java.net.MulticastSocket  建立与服务器端的套接口连接，从而实现“服务器推”。 这种方案最大的不足在于 Java
applet  需要客户端安装JAVA虚拟机 。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h1&gt;3.客户端总结：&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;&lt;p&gt;参考链接：http://blog.csdn.net/shanpengfei77/article/details/8138108
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://blog.csdn.net/sunchaoenter/article/details/7972829
关于Andriod推送一个不错的博客：http://www.androidpush.cn/&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;3.1 概况：&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Push能够有效地激活用户更多地使用 App，目前大多数应用都有Push功能。Push功能依赖于Push服务，现在主流的智能手机操作系统都集成了免费的Push服务，如IPhone的APNS(Apple Push Notification service)、windowsphone的MPNS(Microsoft Push Notification service，Android的GCM (GoogleCloud Messaging)。但是由于Android操作系统是开源的，很多手机厂商都没有预装Google服务，并且Google服务在国内不稳定，所以国内无法使用GCM实现Push功能，这种情况下我们只能使用第三方的Push服务或自己开发Push服务。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;国内应用开发商大多自己部署一个简单的Http服务，客户端每隔一段时间到服务器查询，这种方式的缺点也是显而易见的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ø  HTTP请求的数据包较大，会增加数据流量 Ø  不够及时，如果轮询的时间间隔太短就会很耗电、耗流量&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;3.2 第三方Push服务介绍&lt;/h2&gt;

&lt;p&gt;由于上述一些原因，很多的第三方Push服务应运而生，服务提供商大多数是国外的.
&lt;strong&gt;1、 Urban Airship&lt;/strong&gt;
Urban Airship是业界最知名的一个提供推送服务的平台，每月的推送数量达到5.2亿次，平均每分钟的信息发送量约为1.3万次。
除了基本推送服务外，UrbanAirship还提供Rich Push：让Push信息可以带HTML、视频、音频等多媒体信息。此外，UrbanAirship还为iOS和Android提供In-App Purchase(IAP)服务，帮助开发者处理内容存放和安全支付等问题。Urban Airship提供了一个管理后台。开发者在这里不仅能用信息编辑界面来发送Push，还可以监测Push消息的传达情况，观察用户是否产生了交互等统计信息。
推送服务支持以下三个平台：
Ø  IOS
Ø  Android
Ø  BlackBerry
&lt;strong&gt;2、 push.io&lt;/strong&gt;
push.io也是一个很出名的推送服务平台，已经成功推送了60亿次通知，当然和Urban Airship比还差一大截。&lt;/p&gt;

&lt;p&gt;支持以下平台：
Ø  iOS
Ø  Android
Ø  Windows Phone
Ø  Nokia Ovi and S40
&lt;strong&gt;3、 极光推送&lt;/strong&gt;
极光推送是国产的一个免费的推送服务，架构非常类似Urban Airship，很多后台网页和操作也基本上和Urban Airship一样。
支持的平台：
Ø  Android
Ø  IOS
收费标准：
&lt;strong&gt;&lt;em&gt;免费&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;3.3. 自主开发push服务&lt;/h2&gt;

&lt;p&gt;Push服务是一个很复杂的系统，要考虑到性能、并发量、安全性等因素，这些都是技术上的难题，我们需要慢慢摸索、积累。我们可以参考上述几个服务平台，看看他们是怎么做的。&lt;/p&gt;

&lt;p&gt;设计角度：
Ø  支持多应用，每个应用分配唯一appKey
Ø  支持多平台
Ø  支持发送到所有设备
Ø  支持发送到指定设备
Ø  支持按时间段发送
Ø  及时推送
Ø  统计推送规律&lt;/p&gt;

&lt;p&gt;技术角度：
Ø  使用socket长连接，消息能够及时达到
Ø  优化协议，减少数据包大小
Ø  一般使用json数据格式&lt;/p&gt;

&lt;p&gt;流程：
Ø  生成设备唯一ID
Ø  注册到pushserver
Ø  等待消息
Ø  收到消息
Ø  弹出通知&lt;/p&gt;

&lt;h2&gt;3.4 个人对服务器架构的想法：&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先服务器应该是分布式的、可扩展的，其中一个服务作为总服务，然后架设多个子服务器，终端设备需要先连接到总服务拿到需要连接的子服务器地址，然后再连接到具体的子服务器，总服务用于接收各app运营后台提交的push请求，然后通过子服务器分发到每个终端设备。流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器之间的交互：&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;1.架设总服务
2.架设子服务
3.子服务连接并登录到总服务
4.定时向总服务报告连接情况&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;客户端登录过程：&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;1.连接到总服务并获取子服务器地址
2.连接并登录到子服务
3.到数据库查询有没有发往此客户端的push
4.如果有就发送，发送成功后删除&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;运营后台发送push过程：&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;1.运营后台向总服务发送push数据
2.总服务把数据保存到数据库
3.然后把此push下发到子服务
4.子服务在连接池里查找有没有发送对象
5.发送到对应的客户端并删除数据库里对应的数据&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>伤心情歌--杨宗纬</title>
     <link href="http://itweige.com/GoodSongs"/>
     <updated>2014-05-12T00:00:00+08:00</updated>
     <id>http://itweige.com/GoodSongs</id>
     <content type="html">&lt;h3&gt;今天发现几首不错的杨宗纬的歌曲，听得很有感觉，推荐大家去听下：&lt;/h3&gt;

&lt;h4&gt;《其实都没有》&lt;/h4&gt;

&lt;h4&gt;《初爱》&lt;/h4&gt;

&lt;h4&gt;《给未来的自己》&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/blogImages/yzw.jpg&quot; title=&quot;催泪歌王：杨宗纬&quot; alt=&quot;杨宗纬&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>听雨</title>
     <link href="http://itweige.com/raining"/>
     <updated>2014-05-11T00:00:00+08:00</updated>
     <id>http://itweige.com/raining</id>
     <content type="html">&lt;p&gt;来京快三年了，撑伞的次数屈指可数，有时候也会在心里暗暗后怕，是帝都的蓝天硬生生战胜了抑郁。&lt;/p&gt;

&lt;p&gt;京城令人发指的秋天，蓝的清透，顶着这样的天，要是心底再泛起所谓的忧郁，自己都会鄙视自己。时常也会怀念连绵的阴雨，天色阴暗、空气清新、雨声滴答，单纯而静谧，就算假装想想心事也很有情调。&lt;/p&gt;

&lt;p&gt;不得不说，有时候只是听着雨声，也能换个心情，也能专注起来。&lt;/p&gt;

&lt;p&gt;近来对Chrome插件有点兴趣，又看到&lt;a href=&quot;http://www.rainymood.com&quot; title=&quot;Rainy Mood&quot;&gt;RainyMood&lt;/a&gt;，就试试写一个这样调整气氛心情的插件。Chrome的插件开发体验很棒，待整理下再发博客。另外感谢&lt;a href=&quot;http://www.softicons.com/free-icons/web-icons/vector-stylish-weather-icons-by-bartosz-kaszubowski/cloud-dark-rain-icon&quot;&gt;softicons&lt;/a&gt;提供漂亮的图标。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://movie.douban.com/subject/7054120/&quot; title=&quot;黑镜&quot;&gt;Black Mirror&lt;/a&gt;最近很火，豆瓣评分也非常高。我看完的时候，心中的赞叹感让我觉得应该写篇影评骂一骂，影评还没写，却发现我经常会想起里面的情景，所以我不得不低头承认，他确实拍的有那么一点深刻了。&lt;/p&gt;

&lt;p&gt;美剧有时候看起来很右派，要完美，即使不完美，那一定得是感动。英剧显然就是2B青年的套路。现实有多2B，他就有多现实。把Black Mirror的每一集总结一下就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、我就是单纯要搞你，你看着办吧。&lt;/li&gt;
&lt;li&gt;2、这就是未来。&lt;/li&gt;
&lt;li&gt;3、科技让欺骗无处遁形，很好。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;未来是现世一步步发展过去的。记得之前有一个问题：如果用电流刺激你的大脑，让你得到与真实环境刺激一样的神经感受，那么这到底算什么呢。我相信，总有一天技术会达到，但是现在离那也不遥远，互联网就在做这样的事情，我的这个小插件也是做同样的事情，你说这是杯具呢还是悲剧呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rainingchrome/rain.jpg&quot; alt=&quot;Raining&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>使用Github Pages建独立博客--fork Beiyuu</title>
     <link href="http://itweige.com/github-pages"/>
     <updated>2014-05-11T00:00:00+08:00</updated>
     <id>http://itweige.com/github-pages</id>
     <content type="html">&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;Github&quot;&gt;Github&lt;/a&gt;很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如&lt;a href=&quot;https://github.com/jquery/jquery&quot; title=&quot;jQuery@github&quot;&gt;jQuery&lt;/a&gt;、&lt;a href=&quot;https://github.com/twitter/bootstrap&quot; title=&quot;Twitter@github&quot;&gt;Twitter&lt;/a&gt;等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。&lt;/p&gt;

&lt;p&gt;Github Pages有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
    &lt;li&gt;使用标记语言，比如&lt;a href=&quot;http://markdown.tw&quot;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;无需自己搭建服务器&lt;/li&gt;
    &lt;li&gt;根据Github的限制，对应的每个站有300MB空间&lt;/li&gt;
    &lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然他也有缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;模板系统，相当于静态页发布，适合博客，文档介绍等。&lt;/li&gt;
&lt;li&gt;动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。&lt;/li&gt;
&lt;li&gt;基于Git，很多东西需要动手，不像Wordpress有强大的后台&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。&lt;/p&gt;

&lt;h2&gt;购买、绑定独立域名&lt;/h2&gt;

&lt;p&gt;虽说&lt;a href=&quot;http://www.godaddy.com/&quot; title=&quot;Godaddy&quot;&gt;Godaddy&lt;/a&gt;曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。&lt;/p&gt;

&lt;p&gt;域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。&lt;/p&gt;

&lt;p&gt;流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在&lt;a href=&quot;http://beiyuu.com&quot; title=&quot;BeiYuu&quot;&gt;BeiYuu&lt;/a&gt;也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。&lt;/p&gt;

&lt;p&gt;我们选择&lt;a href=&quot;https://www.dnspod.cn/&quot; title=&quot;DNSPod&quot;&gt;DNSPod&lt;/a&gt;的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;首先添加域名记录，可参考DNSPod的帮助文档：&lt;a href=&quot;https://www.dnspod.cn/Support&quot;&gt;https://www.dnspod.cn/Support&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;在DNSPod自己的域名下添加一条&lt;a href=&quot;http://baike.baidu.com/view/65575.htm&quot;&gt;A记录&lt;/a&gt;，地址就是Github Pages的服务IP地址：207.97.227.245&lt;/li&gt;
    &lt;li&gt;在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：&lt;a href=&quot;https://www.dnspod.cn/support/index/fid/119&quot;&gt;Godaddy注册的域名如何使用DNSPod&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;等待域名解析生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;域名的配置部分完成，跪谢方校长。&lt;/p&gt;

&lt;h2&gt;配置和使用Github&lt;/h2&gt;

&lt;p&gt;Git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本&lt;a href=&quot;http://progit.org/book/zh/&quot; title=&quot;Pro Git中文版&quot;&gt;Git中文教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/list&quot; title=&quot;Windows版Git客户端&quot;&gt;http://code.google.com/p/msysgit/downloads/list&lt;/a&gt;。其他系统的安装也可以参考官方的&lt;a href=&quot;http://help.github.com/mac-set-up-git/&quot; title=&quot;Mac下Git安装&quot;&gt;安装教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。&lt;/p&gt;

&lt;p&gt;在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）：
&lt;img src=&quot;/images/githubpages/bootcamp_1_win_gitbash.jpg&quot; alt=&quot;Git Bash&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1、检查SSH keys的设置&lt;/h3&gt;

&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示“No such file or directory”，跳到第三步，否则继续。&lt;/p&gt;

&lt;h3&gt;2、备份和移除原来的ssh key设置：&lt;/h3&gt;

&lt;p&gt;因为已经存在key文件，所以需要备份旧的数据并删除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
config  id_rsa  id_rsa.pub  known_hosts
$ mkdir key_backup
$ cp id_rsa* key_backup
$ rm id_rsa*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、生成新的SSH Key：&lt;/h3&gt;

&lt;p&gt;输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。
    $ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;
    Generating public/private rsa key pair.
    Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&amp;lt;回车就好&gt;&lt;/p&gt;

&lt;p&gt;然后系统会要你输入加密串（&lt;a href=&quot;http://help.github.com/ssh-key-passphrases/&quot;&gt;Passphrase&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后看到这样的界面，就成功设置ssh key了：
&lt;img src=&quot;/images/githubpages/ssh-key-set.png&quot; alt=&quot;ssh key success&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4、添加SSH Key到GitHub：&lt;/h3&gt;

&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;在GitHub的主页上点击设置按钮：
&lt;img src=&quot;/images/githubpages/github-account-setting.png&quot; alt=&quot;github account setting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：
&lt;img src=&quot;/images/githubpages/bootcamp_1_ssh.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS：如果需要配置多个GitHub账号，可以参看这个&lt;a href=&quot;http://omiga.org/blog/archives/2269&quot;&gt;多个github帐号的SSH key切换&lt;/a&gt;，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令&lt;code&gt;git config --global --unset user.email&lt;/code&gt;删除用户账户设置，在每一个repo下面使用&lt;code&gt;git config --local user.email &#39;你的github邮箱@mail.com&#39;&lt;/code&gt; 命令单独设置用户账户信息&lt;/p&gt;

&lt;h3&gt;5、测试一下&lt;/h3&gt;

&lt;p&gt;可以输入下面的命令，看看设置是否成功，&lt;code&gt;git@github.com&lt;/code&gt;的部分不要修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是下面的反应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要紧张，输入&lt;code&gt;yes&lt;/code&gt;就好，然后会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi &amp;lt;em&amp;gt;username&amp;lt;/em&amp;gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6、设置你的账号信息&lt;/h3&gt;

&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.email &quot;your_email@youremail.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置GitHub的token&lt;/h4&gt;

&lt;p&gt;2012-4-28补充：新版的接口已经不需要配置token了，所以下面这段可以跳过了&lt;/p&gt;

&lt;p&gt;有些工具没有通过SSH来链接GitHub。如果要使用这类工具，你需要找到然后设置你的API Token。&lt;/p&gt;

&lt;p&gt;在GitHub上，你可以点击&lt;em&gt;Account Setting &gt; Account Admin&lt;/em&gt;：
&lt;img src=&quot;/images/githubpages/bootcamp_1_token.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的命令行中，输入下面的命令，把token添加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.token 0123456789your123456789token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你改了GitHub的密码，需要重新设置token。&lt;/p&gt;

&lt;h3&gt;成功了&lt;/h3&gt;

&lt;p&gt;好了，你已经可以成功连接GitHub了。&lt;/p&gt;

&lt;h2&gt;使用GitHub Pages建立博客&lt;/h2&gt;

&lt;p&gt;与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的&lt;code&gt;username.github.io&lt;/code&gt;这样的用户&amp;amp;组织页（站），另一种是依附项目的pages。&lt;/p&gt;

&lt;h3&gt;User &amp;amp; Organization Pages&lt;/h3&gt;

&lt;p&gt;想建立个人博客是用的第一种，形如&lt;code&gt;beiyuu.github.io&lt;/code&gt;这样的可访问的站，每个用户名下面只能建立一个，创建之后点击&lt;code&gt;Admin&lt;/code&gt;进入项目管理，可以看到是这样的：
&lt;img src=&quot;/images/githubpages/user-pages.png&quot; alt=&quot;user pages&quot; /&gt;
而普通的项目是这样的，即使你也是用的&lt;code&gt;othername.github.io&lt;/code&gt;：
&lt;img src=&quot;/images/githubpages/other-pages.png&quot; alt=&quot;other pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建好&lt;code&gt;username.github.io&lt;/code&gt;项目之后，提交一个&lt;code&gt;index.html&lt;/code&gt;文件，然后&lt;code&gt;push&lt;/code&gt;到GitHub的&lt;code&gt;master&lt;/code&gt;分支（也就是普通意义上的主干）。第一次页面生效需要一些时间，大概10分钟左右。&lt;/p&gt;

&lt;p&gt;生效之后，访问&lt;code&gt;username.github.io&lt;/code&gt;就可以看到你上传的页面了，&lt;a href=&quot;http://beiyuu.github.com&quot;&gt;beiyuu.github.com&lt;/a&gt;就是一个例子。&lt;/p&gt;

&lt;p&gt;关于第二种项目&lt;code&gt;pages&lt;/code&gt;，简单提一下，他和用户pages使用的后台程序是同一套，只不过它的目的是项目的帮助文档等跟项目绑定的内容，所以需要在项目的&lt;code&gt;gh-pages&lt;/code&gt;分支上去提交相应的文件，GitHub会自动帮你生成项目pages。具体的使用帮助可以参考&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的官方文档：&lt;/p&gt;

&lt;h3&gt;绑定域名&lt;/h3&gt;

&lt;p&gt;我们在第一部分就提到了在DNS部分的设置，再来看在GitHub的配置，要想让&lt;code&gt;username.github.io&lt;/code&gt;能通过你自己的域名来访问，需要在项目的根目录下新建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，文件内容形如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以绑定在二级域名上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blog.beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要提醒的一点是，如果你使用形如&lt;code&gt;beiyuu.com&lt;/code&gt;这样的一级域名的话，需要在DNS处设置A记录到&lt;code&gt;207.97.227.245&lt;/code&gt;（&lt;strong&gt;这个地址会有变动，&lt;a href=&quot;https://help.github.com/articles/my-custom-domain-isn-t-working&quot;&gt;这里&lt;/a&gt;查看&lt;/strong&gt;），而不是在DNS处设置为CNAME的形式，否则可能会对其他服务（比如email）造成影响。&lt;/p&gt;

&lt;p&gt;设置成功后，根据DNS的情况，最长可能需要一天才能生效，耐心等待吧。&lt;/p&gt;

&lt;h2&gt;Jekyll模板系统&lt;/h2&gt;

&lt;p&gt;GitHub Pages为了提供对HTML内容的支持，选择了&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看&lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/README.textile&quot;&gt;Jekyll官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;你可以直接fork&lt;a href=&quot;https://github.com/beiyuu/beiyuu.github.com&quot;&gt;我的项目&lt;/a&gt;，然后改名，就有了你自己的满足Jekyll要求的文档了，当然你也可以按照下面的介绍自己创建。&lt;/p&gt;

&lt;h3&gt;Jekyll基本结构&lt;/h3&gt;

&lt;p&gt;Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过&lt;code&gt;layout&lt;/code&gt;将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。&lt;/p&gt;

&lt;p&gt;基本的Jekyll结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单介绍一下他们的作用：&lt;/p&gt;

&lt;h4&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;配置文件，用来定义你想要的效果，设置之后就不用关心了。&lt;/p&gt;

&lt;h4&gt;_includes&lt;/h4&gt;

&lt;p&gt;可以用来存放一些小的可复用的模块，方便通过&lt;code&gt;{ % include file.ext %}&lt;/code&gt;（去掉前两个{中或者{与%中的空格，下同）灵活的调用。这条命令会调用_includes/file.ext文件。&lt;/p&gt;

&lt;h4&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这是模板文件存放的位置。模板需要通过&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML front matter&lt;/a&gt;来定义，后面会讲到，&lt;code&gt;{ { content }}&lt;/code&gt;标记用来将数据插入到这些模板中来。&lt;/p&gt;

&lt;h4&gt;_posts&lt;/h4&gt;

&lt;p&gt;你的动态内容，一般来说就是你的博客正文存放的文件夹。他的命名有严格的规定，必须是&lt;code&gt;2012-02-22-artical-title.MARKUP&lt;/code&gt;这样的形式，MARKUP是你所使用标记语言的文件后缀名，根据_config.yml中设定的链接规则，可以根据你的文件名灵活调整，文章的日期和标记语言后缀与文章的标题的独立的。&lt;/p&gt;

&lt;h4&gt;_site&lt;/h4&gt;

&lt;p&gt;这个是Jekyll生成的最终的文档，不用去关心。最好把他放在你的&lt;code&gt;.gitignore&lt;/code&gt;文件中忽略它。&lt;/p&gt;

&lt;h4&gt;其他文件夹&lt;/h4&gt;

&lt;p&gt;你可以创建任何的文件夹，在根目录下面也可以创建任何文件，假设你创建了&lt;code&gt;project&lt;/code&gt;文件夹，下面有一个&lt;code&gt;github-pages.md&lt;/code&gt;的文件，那么你就可以通过&lt;code&gt;yoursite.com/project/github-pages&lt;/code&gt;访问的到，如果你是使用一级域名的话。文件后缀可以是&lt;code&gt;.html&lt;/code&gt;或者&lt;code&gt;markdown&lt;/code&gt;或者&lt;code&gt;textile&lt;/code&gt;。这里还有很多的例子：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;https://github.com/mojombo/jekyll/wiki/Sites&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jekyll的配置&lt;/h3&gt;

&lt;p&gt;Jekyll的配置写在_config.yml文件中，可配置项有很多，我们不去一一追究了，很多配置虽有用但是一般不需要去关心，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/configuration&quot;&gt;官方配置文档&lt;/a&gt;有很详细的说明，确实需要了可以去这里查，我们主要说两个比较重要的东西，一个是&lt;code&gt;Permalink&lt;/code&gt;，还有就是自定义项。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Permalink&lt;/code&gt;项用来定义你最终的文章链接是什么形式，他有下面几个变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;year&lt;/code&gt; 文件名中的年份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;month&lt;/code&gt; 文件名中的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;day&lt;/code&gt; 文件名中的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt; 文件名中的文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories&lt;/code&gt; 文章的分类，如果文章没有分类，会忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-month&lt;/code&gt; 文件名中的除去前缀0的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-day&lt;/code&gt; 文件名中的除去前缀0的日期&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;看看最终的配置效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: pretty&lt;/code&gt; /2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /:month-:day-:year/:title.html&lt;/code&gt; /04-29-2009/slap-chop.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /blog/:year/:month/:day/:title&lt;/code&gt; /blog/2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我使用的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: /:title&lt;/code&gt; /github-pages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;自定义项的内容，例如我们定义了&lt;code&gt;title:BeiYuu的博客&lt;/code&gt;这样一项，那么你就可以在文章中使用&lt;code&gt;{ { site.title }}&lt;/code&gt;来引用这个变量了，非常方便定义些全局变量。&lt;/p&gt;

&lt;h3&gt;YAML Front Matter和模板变量&lt;/h3&gt;

&lt;p&gt;对于使用YAML定义格式的文章，Jekyll会特别对待，他的格式要求比较严格，必须是这样的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前后的&lt;code&gt;---&lt;/code&gt;不能省略，在这之间，你可以定一些你需要的变量，layout就是调用&lt;code&gt;_layouts&lt;/code&gt;下面的某一个模板，他还有一些其他的变量可以使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink&lt;/code&gt; 你可以对某一篇文章使用通用设置之外的永久链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;published&lt;/code&gt; 可以单独设置某一篇文章是否需要发布&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt; 设置文章的分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 设置文章的tag&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面的&lt;code&gt;title&lt;/code&gt;就是自定义的内容，你也可以设置其他的内容，在文章中可以通过&lt;code&gt;{ { page.title }}&lt;/code&gt;这样的形式调用。&lt;/p&gt;

&lt;p&gt;模板变量，我们之前也涉及了不少了，还有其他需要的变量，可以参考官方的文档：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/template-data&quot; title=&quot;Jekyll Template Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/template-data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;使用Disqus管理评论&lt;/h2&gt;

&lt;p&gt;模板部分到此就算是配置完毕了，但是Jekyll只是个静态页面的发布系统，想做到关爽场倒是很容易，如果想要评论呢？也很简单。&lt;/p&gt;

&lt;p&gt;现在专做评论模块的产品有很多，比如&lt;a href=&quot;http://disqus.com/&quot;&gt;Disqus&lt;/a&gt;，还有国产的&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说&lt;/a&gt;，Disqus对现在各种系统的支持都比较全面，到写博客为止，多说现在仅是WordPress的一个插件，所以我这里暂时也使用不了，多说与国内的社交网络紧密结合，还是有很多亮点的，值得期待一下。我先选择了Disqus。&lt;/p&gt;

&lt;p&gt;注册账号什么的就不提了，Disqus支持很多的博客平台，参见下图：
&lt;img src=&quot;/images/githubpages/disqus-site.jpg&quot; alt=&quot;Disqus sites&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们选择最下面的&lt;code&gt;Universal Code&lt;/code&gt;就好，然后会看到一个介绍页面，把下面这段代码复制到你的模板里面，可以只复制到显示文章的模板中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;disqus_thread&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = &#39;example&#39;; // required: replace example with your forum shortname 这个地方需要改成你配置的网站名

    /* * * DON&#39;T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;
        dsq.src = &#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
        (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);
    })();
&amp;lt;/script&amp;gt;
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&amp;gt;comments powered by Disqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&amp;gt;blog comments powered by &amp;lt;span class=&quot;logo-disqus&quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完之后，你也可以做一些异步加载的处理，提高性能，比如我就在最开始页面打开的时候不显示评论，当你想看评论的时候，点击“显示评论”再加载Disqus的模块。代码很简单，你可以参考我的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#disqus_container .comment&#39;).on(&#39;click&#39;,function(){
        $(this).html(&#39;加载中...&#39;);
        var disqus_shortname = &#39;beiyuu&#39;;
        var that = this;
        BYB.includeScript(&#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;,function(){$(that).remove()}); //这是一个加载js的函数
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不喜欢Disqus的样式，你也可以根据他生成的HTML结构，自己改写样式覆盖它的，Disqus现在也提供每个页面的评论数接口，&lt;a href=&quot;http://docs.disqus.com/developers/universal/&quot;&gt;帮助文档&lt;/a&gt;在这里可以看到。&lt;/p&gt;

&lt;h2&gt;代码高亮插件&lt;/h2&gt;

&lt;p&gt;如果写技术博客，代码高亮少不了，有两个可选插件&lt;a href=&quot;http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine&quot;&gt;DlHightLight代码高亮组件&lt;/a&gt;和&lt;a href=&quot;http://code.google.com/p/google-code-prettify/&quot;&gt;Google Code Prettify&lt;/a&gt;。DLHightLight支持的语言相对较少一些，有js、css、xml和html，Google的高亮插件基本上任何语言都支持，也可以自定义语言，也支持自动识别，也有行号的特别支持。&lt;/p&gt;

&lt;p&gt;Google的高亮插件使用也比较方便，只需要在&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;的标签上加入&lt;code&gt;prettyprint&lt;/code&gt;即可。所以我选择了Google Code Prettify。&lt;/p&gt;

&lt;h2&gt;搭建本地jekyll环境&lt;/h2&gt;

&lt;p&gt;这里主要介绍一下在Mac OS X下面的安装过程，其他操作系统可以参考官方的&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Install&quot;&gt;jekyll安装&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作为生活在水深火热的墙内人民，有必要进行下面一步修改gem的源，方便我们更快的下载所需组建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem sources --remove http://rubygems.org/ 
sudo gem sources -a http://ruby.taobao.org/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用Gem安装jekyll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般如果有出错提示，你可能需要这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我到了这一步的时候总是提示错误&lt;code&gt;Failed to build gem native extension&lt;/code&gt;，很可能的一个原因是没有安装rvm，&lt;a href=&quot;https://rvm.io/rvm/install/&quot;&gt;rvm的安装&lt;/a&gt;可以参考这里，或者敲入下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://get.rvm.io | bash -s stable --ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要安装Markdown的解释器，这个需要在你的_config.yml里面设置&lt;code&gt;markdown:rdiscount&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，如果一切顺利的话，本地环境就基本搭建完成了，进入之前我们建立的博客目录，运行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，你就可以通过&lt;code&gt;localhost:4000&lt;/code&gt;来访问了。还有关于&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll bootstrap&lt;/a&gt;的资料，需要自己修改调试的，可以研究一下。&lt;/p&gt;

&lt;p&gt;我在这个过程中还遇到两个诡异的没有解决的问题，一个是我放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，可以通过&lt;code&gt;beiyuu.com/blog&lt;/code&gt;访问的到，但是在本地环境下，总是&lt;code&gt;not found&lt;/code&gt;，很是让人郁闷，看生成的&lt;code&gt;_site&lt;/code&gt;目录下面的文件，也是正常的&lt;code&gt;blog.html&lt;/code&gt;，但就是找不到，只有当我把URL改为&lt;code&gt;localhost:4000/blog.html&lt;/code&gt;的时候，才能访问的到，环境不同真糟糕。&lt;/p&gt;

&lt;p&gt;还有一个是关于&lt;code&gt;category&lt;/code&gt;的问题，根据&lt;code&gt;YAML&lt;/code&gt;的语法，我们在文章头部可以定义文章所属的类别，也可以定义为&lt;code&gt;category:[blog,rss]&lt;/code&gt;这样子的多类别，我在本地试一切正常，但是push到GitHub之后，就无法读取了，真让人着急，没有办法，只能采用别的办法满足我的需求了。这里还有一篇&lt;a href=&quot;http://chxt6896.github.com/blog/2012/02/13/blog-jekyll-native.html&quot;&gt;Jekyll 本地调试之若干问题&lt;/a&gt;，安装中如果有其他问题，也可以对照参考一下。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;如果你跟着这篇不那么详尽的教程，成功搭建了自己的博客，恭喜你！剩下的就是保持热情的去写自己的文章吧。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
